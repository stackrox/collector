version: 2.1
parameters:
  quay-repo:
    type: string
    default: "quay.io/cgorman1"

defaultImage: &defaultImage
  docker:
  - image: "<< pipeline.parameters.quay-repo >>/apollo-ci:collector-0.3.13"
    auth:
      username: $QUAY_CGORMAN1_RO_USER
      password: $QUAY_CGORMAN1_RO_PASSWORD
  working_directory: ~/workspace
  environment:
    ROX_CI_IMAGE: true

defaultMachine: &defaultMachine
  machine:
    image: ubuntu-2004:202104-01

runOnAllTags: &runOnAllTags
  filters:
    tags:
      only: /.*/

runOnAllTagsWithDockerIOPullCtx: &runOnAllTagsWithDockerIOPullCtx
  <<: *runOnAllTags
  context:
    - docker-io-pull
    - quay-cgorman1-readonly

runOnAllTagsWithDockerIOPushCtx: &runOnAllTagsWithDockerIOPushCtx
  <<: *runOnAllTags
  context:
    - docker-io-push
    - quay-cgorman1-readwrite
    - quay-cgorman1-readonly

runOnAllTagsWithIntegrationTestRequires: &runOnAllTagsWithIntegrationTestRequires
  <<: *runOnAllTags
  context:
    - docker-io-push
    - quay-cgorman1-readonly
    - ubuntu-esm-subscription-token # Provides environment variable UBUNTU_ESM_SUBSCRIPTION_TOKEN.
  requires:
  - images
  - ubi-image
  - integration-test-local

orbs:
  slack: circleci/slack@3.4.2

setupGCP: &setupGCP
  run:
    name: Setup GCP env
    command: |
      which gcloud
      which gsutil
      gsutil ver
      gsutil ver -l | grep crcmod
      gcloud version
      cat ~/.boto || true
      echo '[Credentials]' >~/.boto
      echo 'gs_service_key_file = /tmp/gcp.json' >>~/.boto
      echo $GOOGLE_CREDENTIALS_CIRCLECI_COLLECTOR > /tmp/gcp.json
      gcloud auth activate-service-account --key-file /tmp/gcp.json
      gcloud config set project stackrox-ci
      gcloud config set compute/region us-central1
      gcloud config unset compute/zone
      gcloud config set core/disable_prompts True
      gcloud auth list
      gsutil ls gs://collector-build-cache/ || echo "ERROR: Could not ls bucket"

commands:
  initcommand:
    steps:
    - attach_workspace:
        at: ~/workspace
    - run:
        name: Set up environment
        command: |
          cat >>"$BASH_ENV" \<<-EOF
            export WORKSPACE_ROOT="${HOME}/workspace"
          EOF
          [[ -f ~/workspace/shared-env ]] && cat ~/workspace/shared-env >>"$BASH_ENV"

  read-pr-metadata:
    steps:
    - run:
        name: Read PR metadata
        command: |
          ~/workspace/go/src/github.com/stackrox/collector/.circleci/read-labels.sh pr-metadata/labels

  gcloud-init:
    steps:
    - run:
        name: Install and configure gcloud
        working_directory: ~/.config/gcloud
        command: |
          if [[ -z "$ROX_CI_IMAGE" ]]; then
            pip3 install --upgrade pip
            pip3 install wheel
            pip3 install -U crcmod google_compute_engine
            pip3 install -U gcloud gsutil
          fi
          sudo chown circleci:circleci /opt
          gcloud components install gsutil -q
          gcloud components update -q

    - *setupGCP

  docker-login-push:
    steps:
    - run:
        name: Login to Docker Hub with push credentials
        command: |
            docker login -u "$DOCKER_IO_PUSH_USERNAME" -p "$DOCKER_IO_PUSH_PASSWORD"

  quay-login:
    steps:
    - run:
        name: Login to Quay with pull credentials
        command: |
            docker login -u "$QUAY_CGORMAN1_RO_USER" -p "$QUAY_CGORMAN1_RO_PASSWORD" quay.io

  quay-login-push:
    steps:
    - run:
        name: Login to Quay with push credentials
        command: |
            docker login -u "$QUAY_CGORMAN1_RW_USER" -p "$QUAY_CGORMAN1_RW_PASSWORD" quay.io


  stackrox-io-login:
    steps:
    - run:
        name: Docker login to collector.stackrox.io
        command: |
          docker login \
            -u "$STACKROX_IO_PUSH_USERNAME" \
            -p "$STACKROX_IO_PUSH_PASSWORD" \
            collector.stackrox.io

jobs:
  initjob:
    <<: *defaultImage
    steps:
    - checkout:
        path: ~/workspace/go/src/github.com/stackrox/collector

    - add_ssh_keys:
        fingerprints:
        - "32:e2:6d:de:c3:bb:b8:a4:62:89:a1:df:7a:30:37:f2"

    - run:
        name: "Pull git submodule"
        command: |
          git -C ~/workspace/go/src/github.com/stackrox/collector submodule update --init

    - run:
        name: Set up shared environment
        command: |
          cat >~/workspace/shared-env \<<-"EOF"
            export GOPATH="${WORKSPACE_ROOT}/go"
            export SOURCE_ROOT="${GOPATH}/src/github.com/stackrox/collector"
            export COLLECTOR_SOURCE_ROOT="${SOURCE_ROOT}/collector"
            export PATH="${PATH}:${GOPATH}/bin:${WORKSPACE_ROOT}/bin"
            export MAX_LAYER_MB=300
          EOF

    - read-pr-metadata

    - run:
        name: Set COLLECTOR_VERSION
        command: |
          COLLECTOR_VERSION="$(make -s -C ~/workspace/go/src/github.com/stackrox/collector tag)"

          COLLECTOR_TAG="${COLLECTOR_VERSION}"
          GCLOUD_SSH_FINGERPRINT="$(echo ${GCLOUD_SSH_KEY_PUB} | awk '{print $2}' | base64 -d | md5sum | awk '{print $1}')"
          GCP_SSH_KEY_FILE="${HOME}/.ssh/id_rsa_${GCLOUD_SSH_FINGERPRINT}"

          cat >>~/workspace/shared-env \<<-EOF
            export COLLECTOR_VERSION="${COLLECTOR_VERSION}"
            export COLLECTOR_TAG="${COLLECTOR_TAG}"
            export GCP_SSH_KEY_FILE="${GCP_SSH_KEY_FILE}"
          EOF

          if [[ -z "$CIRCLE_TAG" && "$CIRCLE_BRANCH" != "master" && ! -f pr-metadata/labels/build-builder-image ]]; then
          cat >>~/workspace/shared-env \<<-EOF
            export COLLECTOR_BUILDER_TAG="cache"
          EOF
          else
          cat >>~/workspace/shared-env \<<-EOF
            export COLLECTOR_BUILDER_TAG="circle-build-${CIRCLE_WORKFLOW_ID}"
            export BUILD_BUILDER_IMAGE=true
          EOF
          fi
          cat ~/workspace/shared-env

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - go/src/github.com/stackrox/collector
        - pr-metadata
        - shared-env

  lint:
    <<: *defaultImage
    steps:
    - initcommand
    - run:
        name: Install clang-format
        command: |
          sudo bash -c 'printf "deb http://deb.debian.org/debian/ buster-backports main contrib non-free" > /etc/apt/sources.list.d/backports.list'
          sudo apt-get update
          sudo apt-get install -y clang-format-11
          sudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-11 100
    - run:
        name: Lint via clang-format
        command: |
           make -C "${COLLECTOR_SOURCE_ROOT}" check

  builder:
    <<: *defaultMachine
    resource_class: large

    steps:
    - initcommand
    - docker-login-push

    - run:
        name: Restore collector-builder image
        command: |
          docker pull "stackrox/collector-builder:${COLLECTOR_BUILDER_TAG}" || docker pull stackrox/collector-builder:cache || true

    - run:
        name: Build collector-builder image
        command: make -C "${SOURCE_ROOT}" builder

    - run:
        name: Save collector-builder image
        command: |
          docker push "stackrox/collector-builder:${COLLECTOR_BUILDER_TAG}"
          if [[ "$CIRCLE_BRANCH" == "master" ]]; then
            docker tag "stackrox/collector-builder:${COLLECTOR_BUILDER_TAG}" stackrox/collector-builder:cache
            docker push stackrox/collector-builder:cache
          fi

  builder-rhel:
    <<: *defaultMachine
    resource_class: large

    steps:
    - initcommand
    - docker-login-push

    - run:
        name: Restore collector-builder rhel image
        command: |
          docker pull "stackrox/collector-builder:rhel-${COLLECTOR_BUILDER_TAG}" || docker pull stackrox/collector-builder:rhel-cache || true

    - run:
        name: Build collector-builder rhel image
        command: make -C "${SOURCE_ROOT}" builder-rhel

    - run:
        name: Save collector-builder rhel image
        command: |
          docker push "stackrox/collector-builder:rhel-${COLLECTOR_BUILDER_TAG}"
          if [[ "$CIRCLE_BRANCH" == "master" ]]; then
            docker tag "stackrox/collector-builder:rhel-${COLLECTOR_BUILDER_TAG}" stackrox/collector-builder:rhel-cache
            docker push stackrox/collector-builder:rhel-cache
          fi


  prepare-kernels:
    <<: *defaultImage

    steps:
    - initcommand

    - run:
        name: Install patch utility
        command: |
          sudo apt-get install patch

    - run:
        name: Prepare source
        command: |
          mkdir -p ~/kobuild-tmp/versions-src
          SYSDIG_DIR="${SOURCE_ROOT}/sysdig/src" \
              SCRATCH_DIR="${HOME}/scratch" \
              OUTPUT_DIR="${HOME}/kobuild-tmp/versions-src" \
            "${SOURCE_ROOT}/kernel-modules/build/prepare-src"

          versions=(~/kobuild-tmp/versions-src/*)
          [[ "${#versions[@]}" == 1 ]] || {
            echo >&2 "Expected a unique kernel module source version, got:"
            printf >&2 '- %s\n' "${versions[@]}"
            exit 1
          }

          version="$(basename "${versions[0]}" .tgz)"
          MODULE_VERSION="$version"

          cat >>"${WORKSPACE_ROOT}/shared-env" \<<-EOF
            export MODULE_VERSION="${MODULE_VERSION}"
          EOF
          cat >>"$BASH_ENV" \<<-EOF
            export MODULE_VERSION="${MODULE_VERSION}"
          EOF
          echo "Building modules for module version $version"

    - run:
        name: Prepare legacy sources
        command: |
          cd "$SOURCE_ROOT"
          if [[ ! -f RELEASED_VERSIONS ]]; then
            echo "RELEASED_VERSIONS file does not exist!"
            exit 1
          fi

          # get fingerprint from github
          GH_KEY="$(ssh-keyscan github.com 2> /dev/null)"
          GH_FINGERPRINT="$(echo ${GH_KEY} | ssh-keygen -lf - | cut -d" " -f2)"
          # Verify from: https://help.github.com/en/articles/githubs-ssh-key-fingerprints
          GH_FINGERPRINT_VERIFY="SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8"
          [[ "${GH_FINGERPRINT}" == "${GH_FINGERPRINT_VERIFY}" ]] || {
            echo >&2 "Unexpected SSH key fingerprint for github.com : ${GH_FINGERPRINT} != ${GH_FINGERPRINT_VERIFY}"
            exit 1
          }
          mkdir -p ~/.ssh
          echo "${GH_KEY}" > ~/.ssh/known_hosts

          LEGACY_DIR="/tmp/old-sysdig"
          SYSDIG_REL_DIR="sysdig/src"
          git clone git@github.com:stackrox/collector "${LEGACY_DIR}"

          mkdir -p "${WORKSPACE_ROOT}/ko-build"

          # These directories contain a bi-directional mapping from collector to module version.
          # The file structure allows using shell globbing without having to resort to `read` loops
          # etc.
          mkdir -p "${WORKSPACE_ROOT}/ko-build/"{released-collectors,released-modules}

          while IFS='' read -r line || [[ -n "$line" ]]; do
            [[ -n "$line" ]] || continue

            collector_ref="$line"
            echo "Preparing module source archive for collector version ${collector_ref}"

            git -C "${LEGACY_DIR}" submodule deinit "${SYSDIG_REL_DIR}"
            git -C "${LEGACY_DIR}" clean -xdf
            git -C "${LEGACY_DIR}" checkout "${collector_ref}"
            git -C "${LEGACY_DIR}" submodule update --init

            mod_ver_file="${WORKSPACE_ROOT}/ko-build/released-collectors/${collector_ref}"
            SYSDIG_DIR="${LEGACY_DIR}/${SYSDIG_REL_DIR}" \
                SCRATCH_DIR="${HOME}/scratch" \
                OUTPUT_DIR="${HOME}/kobuild-tmp/versions-src" \
              ./kernel-modules/build/prepare-src | tail -n 1 \
                >"${mod_ver_file}"

            # If not building legacy probe version {module_version}, remove source 'kobuild-tmp/versions-src/{module_version}.tgz'
            # and do not add the collector version to 'ko-build/released-modules/{module_version}'.
            if [[ -z "$CIRCLE_TAG" && "$CIRCLE_BRANCH" != "master" && ! -f "${WORKSPACE_ROOT}/pr-metadata/labels/build-legacy-probes" ]]; then
                version="$(< "${mod_ver_file}")"
                [[ "$version" != "$MODULE_VERSION" ]] || continue
                echo "Not building probes for legacy version ${version}"
                rm "${HOME}/kobuild-tmp/versions-src/${version}.tgz"
            else
                echo "${collector_ref}" >> "${WORKSPACE_ROOT}/ko-build/released-modules/$(< "${mod_ver_file}")"
            fi

          done < <(grep -v '^#' <RELEASED_VERSIONS | awk -F'#' '{print $1}' | awk 'NF==2 {print $1}' | sort | uniq)

          rm -rf "${LEGACY_DIR}"

          shopt -s nullglob
          for i in "${WORKSPACE_ROOT}/ko-build/released-modules"/* ; do
            version="$(basename $i .tgz)"
            [[ "$version" != "$MODULE_VERSION" ]] || continue
            echo "Building modules for legacy module version $version"
          done

    - run:
        name: Prepare Kernel module build cache lookup
        command: |
          mkdir -p /tmp/cache
          if [[ -f pr-metadata/labels/no-cache ]]; then
            echo >/tmp/cache/kernel-modules-version.txt
          else
            echo "$MODULE_VERSION" >/tmp/cache/kernel-modules-version.txt
          fi

    - restore_cache:
        name: Restore Kernel module build cache
        keys:
          - kernel-module-cache-v15-{{ checksum "/tmp/cache/kernel-modules-version.txt" }}-{{ .Branch }}-{{ .Revision }}
          - kernel-module-cache-v15-{{ checksum "/tmp/cache/kernel-modules-version.txt" }}-master-

    - run:
        name: Unpack module sources
        command: |
          mkdir -p "${WORKSPACE_ROOT}/ko-build"
          cd "${WORKSPACE_ROOT}/ko-build"

          echo >build-tasks
          mkdir build-output

          for i in ~/kobuild-tmp/versions-src/*.tgz; do
            version="$(basename "$i" .tgz)"
            mkdir -p "module-versions/${version}"
            tar -C "module-versions/${version}" -xvzf "$i"
            mkdir -p "build-output/${MODULE_VERSION}"
          done

    - run:
        name: Copy cached modules to build output
        command: |
          [[ -d "/tmp/cache/kernel-modules/${MODULE_VERSION}/" ]] || exit 0
          mkdir -p "${WORKSPACE_ROOT}/ko-build/cached-probes/${MODULE_VERSION}"
          mv -v \
              "/tmp/cache/kernel-modules/${MODULE_VERSION}"/* \
              "${WORKSPACE_ROOT}/ko-build/cached-probes/${MODULE_VERSION}/" \
            || true

    - gcloud-init

    - run:
        name: Upload module sources
        command: |
          gsutil -m rsync -r ~/kobuild-tmp/versions-src/ "gs://stackrox-kernel-modules-source/collector/"

    - run:
        name: Download missing modules for CURRENT version from gcloud bucket
        command: |
          mkdir -p "${WORKSPACE_ROOT}/ko-build/cached-probes/${MODULE_VERSION}"
          [[ ! -f pr-metadata/labels/no-cache ]] || exit 0
          gsutil -m rsync -r \
            "${COLLECTOR_MODULES_BUCKET}/${MODULE_VERSION}/" \
            "${WORKSPACE_ROOT}/ko-build/cached-probes/${MODULE_VERSION}/" \
            || true

    - run:
        name: Patch module sources
        command: |
          cd "${WORKSPACE_ROOT}/ko-build/module-versions"
          for version in *; do
            [[ -f "${SOURCE_ROOT}/kernel-modules/patches/${version}.patch" ]] || continue
            echo "Applying patch for module version ${version} ..."
            patch -p1 -d "$version" <"${SOURCE_ROOT}/kernel-modules/patches/${version}.patch"
          done

    - run:
        name: Compile list of cached modules for CURRENT module version
        command: |
          ( ls -a "${WORKSPACE_ROOT}/ko-build/cached-probes/${MODULE_VERSION}"/ || true ) \
            | "${SOURCE_ROOT}/kernel-modules/build/extract-kernel-versions-from-module-files" \
            >~/kobuild-tmp/existing-modules-"${MODULE_VERSION}"

    - run:
        name: Compile list of existing modules for LEGACY module versions
        command: |
          for i in "${WORKSPACE_ROOT}/ko-build/module-versions"/*/; do
            version="$(basename "$i")"
            [[ "$version" != "$MODULE_VERSION" ]] || continue
            if [[ -f pr-metadata/labels/no-cache ]] ; then
                echo >~/kobuild-tmp/existing-modules-"${version}"
                echo "Skipping GCS cache for version ${version}:"
                continue
            fi
            ( gsutil ls "${COLLECTOR_MODULES_BUCKET}/${version}/" || true)  \
              | "${SOURCE_ROOT}/kernel-modules/build/extract-kernel-versions-from-module-files" \
                >~/kobuild-tmp/existing-modules-"${version}"

            echo "Existing modules for version ${version}:"
            cat ~/kobuild-tmp/existing-modules-"${version}"
            echo
          done

    - run:
        name: Generate list of all (source, kernel version) build combinations
        command: |
          # all-build-tasks will contain all potentially possible build tasks, i.e., the cross
          # product between the set of kernel versions and the set of module versions
          echo >~/kobuild-tmp/all-build-tasks

          # redundant-build-tasks will contain all build tasks for which we already have the resulting
          # module.
          echo >~/kobuild-tmp/redundant-build-tasks

          cd "${WORKSPACE_ROOT}/ko-build"
          echo >~/kobuild-tmp/all-module-versions

          for i in module-versions/*/; do
            version="$(basename "$i")"
            echo "$version" >>~/kobuild-tmp/all-module-versions

            awk -v modver="$version" '{print $1 " " modver " mod"}' <"${SOURCE_ROOT}/kernel-modules/KERNEL_VERSIONS" >>~/kobuild-tmp/all-build-tasks
            if [[ -d "${i}/bpf" ]]; then
              awk -v modver="$version" '{print $1 " " modver " bpf"}' <"${SOURCE_ROOT}/kernel-modules/KERNEL_VERSIONS" >>~/kobuild-tmp/all-build-tasks
            fi
            awk -v modver="$version" '{print $1 " " modver " " $2}' <~/kobuild-tmp/existing-modules-"${version}" >>~/kobuild-tmp/redundant-build-tasks
          done

          # blocklisted-build-tasks is populated from the BLOCKLIST file to exclude build tasks which would fail.
          "${SOURCE_ROOT}/kernel-modules/build/apply-blocklist.py" "${SOURCE_ROOT}/kernel-modules/BLOCKLIST" \
            ~/kobuild-tmp/all-build-tasks >~/kobuild-tmp/non-blocklisted-build-tasks

          # Create the set of build tasks as the contents of `all-build-tasks` minus the redundant and blocklisted
          # build tasks.
          cat ~/kobuild-tmp/non-blocklisted-build-tasks \
              ~/kobuild-tmp/redundant-build-tasks ~/kobuild-tmp/redundant-build-tasks \
            | sort | uniq -u >build-tasks

    - run:
        name: Print list of all (source, kernel version) build combinations
        command: |
          cd "${WORKSPACE_ROOT}/ko-build"

          num_build_tasks="$(wc -l build-tasks | awk '{print $1}')"
          echo "Building kernel modules for the following kernel/module version/probe type combinations:"
          sed -e 's@^@  @' <build-tasks
          echo "Total: ${num_build_tasks} kernel/module version/probe type combinations."

    - store_artifacts:
        path: ~/kobuild-tmp
    - persist_to_workspace:
        root: ~/workspace
        paths:
          - ko-build
          - bin
          - shared-env

  kernels:
    <<: *defaultMachine
    parallelism: 8
    environment:
    - BUILD_CONTAINER_TAG: stackrox/collector-builder:kobuilder-cache
    - BUILD_CONTAINER_CACHE_IMAGES: stackrox/collector-builder:kobuilder-cache
    - KERNEL_BUNDLES_STAGING_BUCKET: ""

    steps:
    - initcommand

    - run:
        name: Determine tasks for current shard
        command: |
          echo "Nodes total: $CIRCLE_NODE_TOTAL"
          echo "Node index:  $CIRCLE_NODE_INDEX"

          cd "${WORKSPACE_ROOT}/ko-build"
          num_tasks=$(wc -l <build-tasks)
          shard_size=$(((num_tasks - 1) / CIRCLE_NODE_TOTAL + 1))

          echo "Total number of tasks: ${num_tasks}"
          echo "Tasks per shard: ${shard_size}"

          mkdir -p ~/kobuild-tmp
          cd ~/kobuild-tmp
          split -d -l "$shard_size" "${WORKSPACE_ROOT}/ko-build/build-tasks" task-shard-

          this_shard_file=~/kobuild-tmp/task-shard-"$(printf '%02d' "$CIRCLE_NODE_INDEX")"

          if [[ ! -s "$this_shard_file" ]]; then
            echo "Nothing to be done for this shard."
            circleci step halt
            exit 0
          fi

          mv "$this_shard_file" ~/kobuild-tmp/local-build-tasks

          num_build_tasks="$(wc -l ~/kobuild-tmp/local-build-tasks | awk '{print $1}')"
          echo "Building kernel modules for the following kernel/module version/probe type combinations:"
          sed -e 's@^@  @' <~/kobuild-tmp/local-build-tasks
          echo "Total: ${num_build_tasks} kernel/module version/probe type combinations."

          awk '{print $1}' <~/kobuild-tmp/local-build-tasks | sort | uniq >~/kobuild-tmp/all-kernel-versions
          awk '{print $2}' <~/kobuild-tmp/local-build-tasks | sort | uniq >~/kobuild-tmp/all-module-versions

          cd "${WORKSPACE_ROOT}/ko-build/build-output"
          xargs <~/kobuild-tmp/all-module-versions mkdir -p

    - gcloud-init
    - run:
        name: Download required packages
        command: |
          mkdir -p ~/kobuild-tmp/bundles

          awk -v bucket="$KERNEL_BUNDLES_BUCKET" '{print bucket "/bundle-" $1 ".tgz"}' <~/kobuild-tmp/all-kernel-versions \
            | gsutil -m cp -I ~/kobuild-tmp/bundles/ || true

          # Include kernel bundles within env var KERNEL_BUNDLES_STAGING_BUCKET, if it is set on a PR branch
          if [[ -z "$CIRCLE_TAG" && "$CIRCLE_BRANCH" != "master" && ! -z "$KERNEL_BUNDLES_STAGING_BUCKET" ]]; then
            awk -v bucket="$KERNEL_BUNDLES_STAGING_BUCKET" \
              '{print bucket "/bundle-" $1 ".tgz"}' <~/kobuild-tmp/all-kernel-versions \
              | gsutil -m cp -I ~/kobuild-tmp/bundles/ || true
          fi

          ls ~/kobuild-tmp/bundles/

    - run:
        name: Determine versions requiring a custom builder flavor
        command: |
          mkdir -p ~/kobuild-tmp/custom-flavors
          make --quiet -C "${SOURCE_ROOT}/kernel-modules" print-custom-flavors >~/kobuild-tmp/custom-flavors/all
          mkdir ~/kobuild-tmp/meta-inspect
          for bundle_file in ~/kobuild-tmp/bundles/bundle-*.tgz; do
            version="$(basename "$bundle_file" | sed -E 's/^bundle-(.*)\.tgz$/\1/')"
            tar -xzf "${bundle_file}" -C ~/kobuild-tmp/meta-inspect ./BUNDLE_DISTRO ./BUNDLE_VERSION ./BUNDLE_MAJOR
            distro="$(< ~/kobuild-tmp/meta-inspect/BUNDLE_DISTRO)"
            kernel_version="$(< ~/kobuild-tmp/meta-inspect/BUNDLE_VERSION)"
            kernel_major="$(< ~/kobuild-tmp/meta-inspect/BUNDLE_MAJOR)"
            flavor="default"
            if [[ "$distro" == "debian" ]] ; then
              build_id="$(echo "${version}" | cut -d '-' -f2)"
              if (( kernel_version >= 5 )); then
                if (( kernel_version > 5 || (( kernel_version == 5 && kernel_major > 10 )) )); then
                  flavor="hirsute"
                else
                  flavor="modern"
                fi
              elif (( build_id >= 14 )); then
                flavor="modern"
              fi
            # SUSE and all kernels >= 5 can use modern builder
            elif [[ "$distro" =~ ^suse$|^dockerdesktop$ ]] || (( kernel_version >= 5 )); then
              if (( kernel_version > 5 || (( kernel_version == 5 && kernel_major > 10 )) || (( "$distro" == "flatcar" && kernel_version == 5 && kernel_major == 10  )) )); then
                flavor="hirsute"
              else
                flavor="modern"
              fi
            # RHEL 8.3+ kernels require a newer gcc and can be compiled with modern builder
            #  Match kernels of the form 4.18.0-240.1.1.el8_3.x86_64 and 4.18.0-301.1.el8.x86_64
            elif [[ "$distro" == "redhat" && "$version" =~ ^.*(el8_[3-9]|[3-9][0-9][0-9][.0-9]+el8)\.x86_64$ ]]; then
              flavor="modern"
            elif [[ "$distro" == "redhat" && "$version" == "4.18.0-293.el8.x86_64" ]]; then
              flavor="modern"
            elif [[ "$distro" == "debian" && "$version" =~ ^4.19.0-17(-cloud|)-amd64$ ]]; then
              flavor="modern"
            elif grep -q "$distro" <~/kobuild-tmp/custom-flavors/all; then
              flavor="$distro"
            fi
            if [[ "$flavor" != "default" ]]; then
              echo "$version" >>~/kobuild-tmp/custom-flavors/versions."$flavor"
            fi
            echo "Building kernel version $version with $flavor builder"
          done

    - run:
        name: Separate local build tasks by flavor
        command: |
          # Handle the case that glob doesn't match anything
          shopt -s nullglob

          for f in ~/kobuild-tmp/custom-flavors/versions.*; do
            flavor="$(basename "$f")"
            flavor="${flavor#versions\.}"
            join -1 1 -2 1 -o'1.1,1.2,1.3' <(sort -k 1b,1 <~/kobuild-tmp/local-build-tasks) <(sort -k 1b,1 <"$f") >~/kobuild-tmp/local-build-tasks."$flavor"
          done
          cat ~/kobuild-tmp/local-build-tasks.* ~/kobuild-tmp/local-build-tasks | sort | uniq -u >~/kobuild-tmp/local-build-tasks.default
          rm ~/kobuild-tmp/local-build-tasks

    - docker-login-push

    - run:
        name: Restore builder cache image(s)
        command: |
          make -C "${SOURCE_ROOT}/kernel-modules" pull-build-containers

    - run:
        name: Build builder image
        command: |
          make -C "${SOURCE_ROOT}/kernel-modules" build-container
          docker tag "$BUILD_CONTAINER_TAG" build-kernel-modules-default

          shopt -s nullglob

          for f in ~/kobuild-tmp/custom-flavors/versions.*; do
            flavor="$(basename "$f")"
            flavor="${flavor#versions\.}"
            make -C "${SOURCE_ROOT}/kernel-modules" "build-container-${flavor}"
            docker tag "${BUILD_CONTAINER_TAG}-${flavor}" "build-kernel-modules-${flavor}"
          done

    - run:
        name: Upload builder cache image
        command: |
          # [[ "$CIRCLE_BRANCH" == "master" ]] || exit 0
          (( CIRCLE_NODE_INDEX == 0 )) || exit 0
          make -C "${SOURCE_ROOT}/kernel-modules" push-build-containers
        background: true

    - run:
        name: Build modules
        command: |
          shopt -s nullglob

          shard_output_dir="${WORKSPACE_ROOT}/ko-build/build-output/shard-${CIRCLE_NODE_INDEX}"
          mkdir "${shard_output_dir}"
          for task_file in ~/kobuild-tmp/local-build-tasks.*; do
            [[ -s "$task_file" ]] || continue
            flavor="$(basename "${task_file}")"
            flavor="${flavor#local-build-tasks\.}"
            echo "Building kernel modules with flavor $flavor"

            docker run --rm -i \
              -v "${HOME}/kobuild-tmp/bundles:/bundles:ro" \
              -v "${WORKSPACE_ROOT}/ko-build/module-versions:/sources:ro" \
              -v "${shard_output_dir}:/output" \
              --tmpfs /scratch:exec \
              "build-kernel-modules-${flavor}" \
              build-kos <"$task_file"
          done
          sudo chown -R "$(id -u):$(id -g)" "$shard_output_dir"
          find "${shard_output_dir}/FAILURES" -type d -empty -depth -exec rmdir {} \;
          [[ ! -d "${shard_output_dir}/FAILURES" ]] \
            || mv "${shard_output_dir}/FAILURES" "${shard_output_dir}/../FAILURES-${CIRCLE_NODE_INDEX}"

    - run:
        name: Print built modules
        command: |
          shard_output_dir="${WORKSPACE_ROOT}/ko-build/build-output/shard-${CIRCLE_NODE_INDEX}"
          for i in "${WORKSPACE_ROOT}/ko-build/module-versions"/*/; do
            version="$(basename "$i")"
            if [[ -d "${shard_output_dir}/$version" ]]; then
              find "${shard_output_dir}/${version}" -type f -ls
            fi
          done

    - persist_to_workspace:
        root: ~/workspace
        paths:
          - ko-build/build-output/shard-*
          - ko-build/build-output/FAILURES-*

  collector:
    <<: *defaultMachine
    resource_class: large

    steps:
    - initcommand
    - docker-login-push

    - run:
        name: Restore collector-builder image
        command: |
          docker pull "stackrox/collector-builder:${COLLECTOR_BUILDER_TAG}"

    - run:
        name: Build collector
        command: make -C "${SOURCE_ROOT}" collector

    - run:
        name: Run collector unit tests
        command: make -C "${SOURCE_ROOT}" unittest

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - go/src/github.com/stackrox/collector/collector/container/bin
        - go/src/github.com/stackrox/collector/collector/container/libs
        - go/src/github.com/stackrox/collector/collector/container/THIRD_PARTY_NOTICES

  collector-rhel:
    <<: *defaultMachine
    resource_class: large

    steps:
    - initcommand
    - docker-login-push

    - run:
        name: Restore collector-builder rhel image
        command: |
          docker pull "stackrox/collector-builder:rhel-${COLLECTOR_BUILDER_TAG}"

    - run:
        name: Build rhel collector
        command: make -C "${SOURCE_ROOT}" collector-rhel

    - run:
        name: Run RHEL collector unit tests
        command: make -C "${SOURCE_ROOT}" unittest-rhel

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - go/src/github.com/stackrox/collector/collector/container/bin
        - go/src/github.com/stackrox/collector/collector/container/libs
        - go/src/github.com/stackrox/collector/collector/container/THIRD_PARTY_NOTICES.rhel

  images:
    <<: *defaultMachine
    environment:
    - INSTALL_DIRECTORY: /tmp
    - QUAY_REPO: << pipeline.parameters.quay-repo >>
    - DOCKER_REPO: "docker.io/stackrox"

    steps:
    - initcommand
    - docker-login-push
    - quay-login-push
    - gcloud-init

    - run:
        name: Copying Kernel modules build output
        command: |
          mkdir -p "${SOURCE_ROOT}/kernel-modules/container/kernel-modules"
          mv "${WORKSPACE_ROOT}/ko-build/built-probes/${MODULE_VERSION}/"* \
            "${SOURCE_ROOT}/kernel-modules/container/kernel-modules" || true
          rm -f "${SOURCE_ROOT}/kernel-modules/container/kernel-modules/".*.unavail || true

          ls "${SOURCE_ROOT}/kernel-modules/container/kernel-modules"

    - run:
        name: Copying Kernel modules from cache
        command: |
          cp -n "${WORKSPACE_ROOT}/ko-build/cached-probes/${MODULE_VERSION}"/* \
            "${SOURCE_ROOT}/kernel-modules/container/kernel-modules" || true
          rm -f "${SOURCE_ROOT}/kernel-modules/container/kernel-modules/".*.unavail || true

          ls "${SOURCE_ROOT}/kernel-modules/container/kernel-modules"

    - run:
        name: Preparing Kernel modules build cache
        command: |
          mkdir -p "/tmp/cache/kernel-modules/${MODULE_VERSION}/"
          cp -rl "${SOURCE_ROOT}/kernel-modules/container/kernel-modules/." \
            "/tmp/cache/kernel-modules/${MODULE_VERSION}/"
          echo "$MODULE_VERSION" >/tmp/cache/kernel-modules-version.txt

    - save_cache:
        name: Saving Kernel module build cache
        key: kernel-module-cache-v15-{{ checksum "/tmp/cache/kernel-modules-version.txt" }}-{{ .Branch }}-{{ .Revision }}
        paths:
          - /tmp/cache/

    - run:
        name: Adding Kernel module version and license files
        command: |
          mkdir -p "${SOURCE_ROOT}/kernel-modules/container/kernel-modules"
          echo "$MODULE_VERSION" \
            >>"${SOURCE_ROOT}/kernel-modules/container/kernel-modules/MODULE_VERSION.txt"
          cp "${SOURCE_ROOT}"/collector/LICENSE-kernel-modules.txt "${SOURCE_ROOT}"/collector/container/

    - run:
        name: Load any missing modules from GCloud
        command: |
          gsutil -m cp -n \
              "${COLLECTOR_MODULES_BUCKET}/${MODULE_VERSION}/*.gz" \
              "${SOURCE_ROOT}/kernel-modules/container/kernel-modules" || true

    - run:
        name: Sanity check
        command: |
          cd "$SOURCE_ROOT"
          echo '>>> Collector Artifacts:'
          find collector/container
          echo '>>> Kernel Modules:'
          find kernel-modules/container

    - run:
        name: Build collector slim and base images
        command: |
          build_args=(
            --build-arg module_version="$MODULE_VERSION"
            --build-arg collector_version="$COLLECTOR_VERSION"
          )

          docker build \
            -t "${DOCKER_REPO}/collector:${COLLECTOR_VERSION}-base" \
            -t "${DOCKER_REPO}/collector:${COLLECTOR_VERSION}-slim" \
            -t "${QUAY_REPO}/collector:${COLLECTOR_VERSION}-base" \
            -t "${QUAY_REPO}/collector:${COLLECTOR_VERSION}-slim" \
            "${build_args[@]}" \
            ${SOURCE_ROOT}/collector/container

          "${SOURCE_ROOT}/collector/container/rhel/create-bundle.sh" \
            "$SOURCE_ROOT/collector/container" \
            "-" \
            "$SOURCE_ROOT/collector/container/rhel"

          docker build \
            -t "${DOCKER_REPO}/collector-rhel:${COLLECTOR_VERSION}-base" \
            -t "${DOCKER_REPO}/collector-rhel:${COLLECTOR_VERSION}-slim" \
            -t "${QUAY_REPO}/collector-rhel:${COLLECTOR_VERSION}-base" \
            -t "${QUAY_REPO}/collector-rhel:${COLLECTOR_VERSION}-slim" \
            "${build_args[@]}" \
            -f ${SOURCE_ROOT}/collector/container/rhel/Dockerfile \
            "$SOURCE_ROOT/collector/container/rhel"

    - run:
        name: Build collector -latest images
        command: |
          collector_repos=(
            "collector"
            "collector-rhel"
          )

          # On PR branches, only build slim images
          if [[ "$CIRCLE_BRANCH" != "master" && -z "$CIRCLE_TAG" && ! -f "${WORKSPACE_ROOT}/pr-metadata/labels/build-full-images" ]]; then
            echo "Not building full images, re-tagging base images..."
            for collector_repo in "${collector_repos[@]}"; do
              docker_full_repo="${DOCKER_REPO}/${collector_repo}:${COLLECTOR_VERSION}"
              quay_full_repo="${QUAY_REPO}/${collector_repo}:${COLLECTOR_VERSION}"
              docker tag "${docker_full_repo}-base" "${docker_full_repo}"
              docker tag "${docker_full_repo}-base" "${docker_full_repo}-latest"
              docker tag "${quay_full_repo}-base" "${quay_full_repo}"
              docker tag "${quay_full_repo}-base" "${quay_full_repo}-latest"
            done
            exit 0
          fi

          container_build_dir="${SOURCE_ROOT}/kernel-modules/container"
          layer_count="$("${container_build_dir}/partition-probes.py" -1 "$MAX_LAYER_MB" "${container_build_dir}/kernel-modules" "-")"
          for collector_repo in "${collector_repos[@]}"; do
            build_args=(
              --build-arg collector_repo="${DOCKER_REPO}/${collector_repo}"
              --build-arg collector_version="$COLLECTOR_VERSION"
              --build-arg module_version="$MODULE_VERSION"
              --build-arg max_layer_size="$MAX_LAYER_MB"
              --build-arg max_layer_depth="$layer_count"
            )
            docker build \
              --target="probe-layer-${layer_count}" \
              -t "${DOCKER_REPO}/${collector_repo}:${COLLECTOR_VERSION}" \
              -t "${DOCKER_REPO}/${collector_repo}:${COLLECTOR_VERSION}-latest" \
              -t "${QUAY_REPO}/${collector_repo}:${COLLECTOR_VERSION}" \
              -t "${QUAY_REPO}/${collector_repo}:${COLLECTOR_VERSION}-latest" \
              "${build_args[@]}" \
              "${container_build_dir}"
          done

    - run:
        name: Sanity check images
        command: |
          docker images | grep collector | grep "${COLLECTOR_VERSION}"
          docker images | grep collector | grep "${COLLECTOR_VERSION}-slim"

    - run:
        name: Push images
        command: |
          image_repos=(
            "${DOCKER_REPO}/collector"
            "${DOCKER_REPO}/collector-rhel"
            "${QUAY_REPO}/collector"
            "${QUAY_REPO}/collector-rhel"
          )
          image_tags=(
            "${COLLECTOR_VERSION}"
            "${COLLECTOR_VERSION}-base"
            "${COLLECTOR_VERSION}-slim"
            "${COLLECTOR_VERSION}-latest"
          )
          for repo in "${image_repos[@]}"; do
            for tag in "${image_tags[@]}"; do
              image="${repo}:${tag}"
              echo "Pushing image ${image}"
              docker image inspect "${image}" >/dev/null
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${image}"
            done
          done

  ubi-image:
    machine:
      image: ubuntu-2004:202010-01
      docker_layer_caching: true
    resource_class: large
    environment:
    - QUAY_REPO: << pipeline.parameters.quay-repo >>
    - DOCKER_REPO: "docker.io/stackrox"

    steps:
    - initcommand
    - docker-login-push
    - quay-login-push
    - run:
        name: Lint Dockerfile
        command: |
          docker run --rm -i hadolint/hadolint < \
            ${SOURCE_ROOT}/collector/container/Dockerfile.ubi

    - run:
        name: Build collector UBI images
        command: |

          docker build \
            --build-arg COLLECTOR_VERSION=${COLLECTOR_VERSION} \
            --build-arg REDHAT_USERNAME="${REDHAT_USERNAME}" \
            --build-arg REDHAT_PASSWORD="${REDHAT_PASSWORD}" \
            -t "collector-test-cpaas:${COLLECTOR_VERSION}" \
            -f ${SOURCE_ROOT}/collector/container/Dockerfile.ubi \
            ${SOURCE_ROOT}

    - run:
        name: Push collector UBI images
        command: |
          image_repos=(
            "${DOCKER_REPO}/collector-test-cpaas"
            "${QUAY_REPO}/collector-test-cpaas"
          )
          image_tags=(
            "${COLLECTOR_VERSION}"
            "${COLLECTOR_VERSION}-slim"
          )
          for repo in "${image_repos[@]}"; do
            for tag in "${image_tags[@]}"; do
              image="${repo}:${tag}"
              docker image tag "collector-test-cpaas:${COLLECTOR_VERSION}" "${image}"
              docker push "${image}"
            done
          done

  kernel-module-build-failures-check:
    <<: *defaultImage

    steps:
      - initcommand

      - run:
          name: Save failures files
          command: |
            mkdir /tmp/failures
            cp -r "${WORKSPACE_ROOT}/ko-build/build-output/FAILURES"-*/. /tmp/failures || true

      - run:
          name: Test for build failures
          command: |
            shopt -s nullglob
            cd /tmp/failures
            failure_files=(*/*/*.log)

            for failure_file in "${failure_files[@]}"; do
              if [[ "$failure_file" =~ ^([^/]+)/([^/]+)/([^/]+)\.log$ ]]; then
                kernel_version="${BASH_REMATCH[1]}"
                module_version="${BASH_REMATCH[2]}"
                probe_type="${BASH_REMATCH[3]}"
                echo >&2 "============================================================================"
                echo >&2 "Failed to build ${probe_type} probe"
                echo >&2 "Module version: ${module_version}"
                echo >&2 "Kernel version: ${kernel_version}"
                echo >&2
                cat >&2 "$failure_file"
                echo >&2
                echo >&2
              fi
            done

            [[ "${#failure_files[@]}" == 0 ]]

      - store_artifacts:
          path: /tmp/failures

      - slack/status:
          fail_only: true
          mentions: SGX5Y89KJ
          only_for_branches: master
          webhook: '${SLACK_WEBHOOK_KERNEL_PROBE_BUILD_FAILURE}'

  join-modules:
    <<: *defaultImage

    steps:
      - initcommand

      - run:
          name: Consolidate modules built by sharded jobs
          command: |
            shopt -s nullglob
            shopt -s dotglob
            mkdir -p "${WORKSPACE_ROOT}/ko-build/built-probes"
            shard_dirs=("${WORKSPACE_ROOT}/ko-build/build-output/shard-"*)
            if [[ "{#shard_dirs[@]}" == 0 ]]; then
              exit 0
            fi
            for shard_dir in "${shard_dirs[@]}"; do
              for version_dir in "${WORKSPACE_ROOT}/ko-build/module-versions"/*/; do
                version="$(basename "$version_dir")"
                job_dir="${shard_dir}/${version}"
                [[ -d "${job_dir}" ]] || continue
                out_dir="${WORKSPACE_ROOT}/ko-build/built-probes/${version}/"
                mkdir -p "$out_dir"
                files=("${job_dir}"/*.{gz,unavail})
                echo "${#files[@]} files in ${job_dir}"
                [[ "${#files[@]}" > 0 ]] || continue
                mv "${job_dir}"/*.{gz,unavail} "$out_dir"
              done
            done

      - persist_to_workspace:
          root: ~/workspace
          paths:
            - ko-build/built-probes/

  upload-modules:
    <<: *defaultImage

    steps:
      - initcommand
      - gcloud-init

      - run:
          name: Remove failures file and shard output dirs
          command: |
            rm -rf "${WORKSPACE_ROOT}/ko-build/build-output/FAILURES"-* 2>/dev/null || true
            rm -rf "${WORKSPACE_ROOT}/ko-build/build-output/shard"-* 2>/dev/null || true

      - run:
          name: Uploading Kernel modules
          command: |
            extra_args=()
            target="${COLLECTOR_MODULES_BUCKET}"
            if [[ "$CIRCLE_BRANCH" != "master" && -z "$CIRCLE_TAG" ]]; then
              target="gs://stackrox-collector-modules-staging/pr-builds/${CIRCLE_BRANCH}/${CIRCLE_BUILD_NUM}"
            fi

            shopt -s nullglob
            shopt -s dotglob
            for probes_dir in "${WORKSPACE_ROOT}/ko-build/built-probes"/*; do
              files=("${probes_dir}"/*.{gz,unavail})
              [[ "${#files[@]}" > 0 ]] || continue
              printf '%s\n' "${files[@]}" | gsutil -m cp -n -I "${target}/$(basename "$probes_dir")/"
            done

            if [[ "$CIRCLE_BRANCH" == "master" || -n "$CIRCLE_TAG" ]]; then
              # On PR/master builds, additionally upload modules from cache
              for probes_dir in "${WORKSPACE_ROOT}/ko-build/cached-probes"/*; do
                files=("${probes_dir}"/*.{gz,unavail})
                [[ "${#files[@]}" > 0 ]] || continue
                printf '%s\n' "${files[@]}" | gsutil -m cp -n -I "${target}/$(basename "$probes_dir")/"
              done
            fi

      - run:
          name: Sanity check
          command: |
            if [[ "$CIRCLE_BRANCH" != "master" && -z "$CIRCLE_TAG" ]]; then
              exit 0
            fi
            gsutil ls "${COLLECTOR_MODULES_BUCKET}/${MODULE_VERSION}/"


  integration-test-local:
    parameters:
      vm-config:
        type: string
        default: default
      use-rhel:
        type: boolean
        default: false
      use-ubi:
        type: boolean
        default: false

    <<: *defaultMachine
    working_directory: ~/workspace

    steps:
    - initcommand
    - docker-login-push
    - gcloud-init

    - run:
        name: "Running integration tests"
        no_output_timeout: 45m
        command: |
          export REMOTE_HOST_TYPE=local
          export COLLECTION_METHOD=kernel_module
          export VM_CONFIG="circle_local_<< parameters.vm-config >>"
          export COLLECTOR_REPO="stackrox/collector<<# parameters.use-rhel>>-rhel<</ parameters.use-rhel>><<# parameters.use-ubi>>-test-cpaas<</ parameters.use-ubi>>"
          export COLLECTOR_IMAGE="${COLLECTOR_REPO}:${COLLECTOR_TAG}"
          make -C "${SOURCE_ROOT}" integration-tests-missing-proc-scrape integration-tests-image-label-json integration-tests integration-tests-report
          [[ -z "$CIRCLE_BRANCH" ]] || gsutil cp ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml "gs://stackrox-ci-results/circleci/collector/${CIRCLE_BRANCH}/$(date +%Y-%m-%d)-${CIRCLE_BUILD_NUM}/"

    - store_test_results:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
    - store_artifacts:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
        destination: "integration-test-report.xml"
    - store_artifacts:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/container-logs
        destination: "container-logs"
    - store_artifacts:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/perf.json
        destination: "kernel_module-circle_local_<< parameters.vm-config >>-perf.json"

  integration-test:
    parameters:
      collection_method:
        type: enum
        enum: [module, ebpf]
      vm_type:
        type: enum
        enum: [cos, rhel, suse, suse-sap, ubuntu-os, flatcar]
      image_family:
        type: enum
        enum: [cos-beta, cos-dev, cos-stable, cos-89-lts, cos-85-lts, cos-81-lts, rhel-7, rhel-8, ubuntu-1604-lts, ubuntu-1804-lts, ubuntu-2004-lts, ubuntu-2104, sles-12, sles-15, sles-15-sp2-sap, flatcar-stable]
      offline:
        type: boolean
        default: false
    <<: *defaultImage

    steps:
    - initcommand
    - run:
        name: Check whether to run job
        command: |
          if [[ -f ~/workspace/pr-metadata/labels/skip-integration-tests ]]; then
            echo "Skipping job with skip-integration-tests label."
            circleci step halt
            exit 0
          fi
    - add_ssh_keys
    - gcloud-init

    - run:
        name: "Extract gcp ssh public key from environment variable"
        command: |
          echo "${GCLOUD_SSH_KEY_PUB}" > "${GCP_SSH_KEY_FILE}.pub"
          chmod 0600 "${GCP_SSH_KEY_FILE}.pub"

    - run:
        name: "Create VM"
        command: |
          source $SOURCE_ROOT/.circleci/create-vm.sh
          export TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          export GCLOUD_INSTANCE="collector-ci-${TEST_NAME}-${CIRCLE_BUILD_NUM}"
          export VM_TYPE=<< parameters.vm_type >>
          export IMAGE_FAMILY=<< parameters.image_family >>
          main "$GCLOUD_INSTANCE" "$VM_TYPE" "$IMAGE_FAMILY" "$GCP_SSH_KEY_FILE" "$DOCKER_IO_PUSH_USERNAME" "$DOCKER_IO_PUSH_PASSWORD"

    - run:
        name: "Running integration tests"
        no_output_timeout: 45m
        command: |
          export REMOTE_HOST_TYPE=gcloud
          export COLLECTION_METHOD="<< parameters.collection_method >>"
          export COLLECTOR_OFFLINE_MODE="<< parameters.offline >>"
          export ROX_COLLECTOR_ALT_PROBE_DOWNLOAD=true
          export VM_CONFIG="<< parameters.vm_type >>.<< parameters.image_family >>"
          export TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          export GCLOUD_INSTANCE="collector-ci-${TEST_NAME}-${CIRCLE_BUILD_NUM}"
          export GCLOUD_OPTIONS="--ssh-key-file=${GCP_SSH_KEY_FILE}"
          export TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          if "${SOURCE_ROOT}/.circleci/pr_has_label.sh" ci-run-against-rhel; then
            export COLLECTOR_REPO="stackrox/collector-rhel"
          elif "${SOURCE_ROOT}/.circleci/pr_has_label.sh" ci-run-against-ubi; then
            export COLLECTOR_REPO="stackrox/collector-test-cpaas"
          else
            export COLLECTOR_REPO="stackrox/collector"
          fi
          make -C "${SOURCE_ROOT}" integration-tests-baseline integration-tests integration-tests-report
          cp "${SOURCE_ROOT}/integration-tests/perf.json" "${WORKSPACE_ROOT}/${TEST_NAME}-perf.json"
          [[ -z "$CIRCLE_BRANCH" ]] || gsutil cp "${SOURCE_ROOT}/integration-tests/integration-test-report.xml" "gs://stackrox-ci-results/circleci/collector/${CIRCLE_BRANCH}/$(date +%Y-%m-%d)-${CIRCLE_BUILD_NUM}/"

    - run:
        name: "Get serial port output"
        command: |
          export TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          export GCLOUD_INSTANCE="collector-ci-${TEST_NAME}-${CIRCLE_BUILD_NUM}"
          mkdir -p ~/workspace/serial-output
          gcloud compute instances get-serial-port-output "$GCLOUD_INSTANCE" > ~/workspace/serial-output/"$GCLOUD_INSTANCE"-serial-output.logs
        when: always

    - store_test_results:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
    - store_artifacts:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
        destination: "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-integration-test-report.xml"
    - store_artifacts:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/container-logs
        destination: "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-container-logs"
    - store_artifacts:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/perf.json
        destination: "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-perf.json"
    - store_artifacts:
        path: ~/workspace/serial-output

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-perf.json"

    - run:
        name: "Destroy VM"
        command: |
          export TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          export GCLOUD_INSTANCE="collector-ci-${TEST_NAME}-${CIRCLE_BUILD_NUM}"
          gcloud compute instances delete $GCLOUD_INSTANCE
        when: always

  integration-test-data:
    <<: *defaultImage

    steps:
    - initcommand
    - run:
        name: Check whether to run job
        command: |
          if [[ -f ~/workspace/pr-metadata/labels/skip-integration-tests ]]; then
            echo "Skipping job with skip-integration-tests label."
            circleci step halt
            exit 0
          fi

    - run:
        name: "Gather Data"
        command: |
          echo "ls 1"
          for i in "${WORKSPACE_ROOT}"/*perf.json; do
            echo "Performance data file: $i"
            cat $i >> ~/workspace/all-perf.json
          done
          ## TODO put into script
          cat all-perf.json | jq '. | select(.Metrics.hackbench_avg_time != null) | {kernel: .VmConfig, collection_method: .CollectionMethod, (.TestName): .Metrics.hackbench_avg_time } ' | jq -rs  ' group_by(.kernel) | .[] | group_by(.collection_method) | .[] | add | [.kernel, .collection_method, .baseline_benchmark, .collector_benchmark ] | @csv' > ~/workspace/benchmark.csv
          cat ~/workspace/benchmark.csv | sort | awk -v FS="," 'BEGIN{print "|Kernel|Method|Without Collector Time (secs)|With Collector Time (secs)|";print "|---|---|---|---|"}{printf "|%s|%s|%s|%s|%s",$1,$2,$3,$4,ORS}' > ~/workspace/benchmark.md

    - run:
        name: Comment on PR
        command: |
          wget --quiet https://github.com/joshdk/hub-comment/releases/download/0.1.0-rc6/hub-comment_linux_amd64
          sudo install hub-comment_linux_amd64 /usr/bin/hub-comment

          export COLLECTOR_TAG="${COLLECTOR_TAG}"
          export COLLECTOR_BUILDER_TAG="${COLLECTOR_BUILDER_TAG}"
          export PERF_TABLE=$(cat ~/workspace/benchmark.md)
          hub-comment -template-file "${SOURCE_ROOT}/.circleci/performance-comment-template.tpl"

    - store_artifacts:
        path: ~/workspace/all-perf.json
    - store_artifacts:
        path: ~/workspace/benchmark.md
    - store_artifacts:
        path: ~/workspace/benchmark.csv

  update-support-packages:
    <<: *defaultImage
    environment:
      - DOWNLOAD_BASE_URL: "https://install.stackrox.io"
      - RELATIVE_PATH: "collector/support-packages"
      - GCLOUD_BUCKET: "gs://sr-roxc"

    steps:
      - initcommand
      - read-pr-metadata
      - run:
          name: Check whether to run job
          command: |
            if [[ "$CIRCLE_BRANCH" != "master" && ! -f ~/workspace/pr-metadata/labels/test-support-packages ]]; then
              echo "On a PR without the test-support-packages label. Not building support packages."
              circleci step halt
            fi

      - setup_remote_docker
      - stackrox-io-login
      - gcloud-init

      - run:
          name: Initialize environment
          command: |
            relative_path="$RELATIVE_PATH"
            if [[ "$CIRCLE_BRANCH" != "master" ]]; then
              relative_path="${relative_path}/.test-${CIRCLE_BUILD_NUM}"
            fi
            cci-export BASE_URL "${DOWNLOAD_BASE_URL}/${relative_path}"
            cci-export SUPPORT_PKG_SRC_ROOT "${SOURCE_ROOT}/kernel-modules/support-packages"
            cci-export LICENSE_FILE "${SOURCE_ROOT}/collector/LICENSE-kernel-modules.txt"
            cci-export GCLOUD_TARGET "${GCLOUD_BUCKET}/${relative_path}"

      - run:
          name: Install Jinja2
          command: |
            pip install Jinja2

      - run:
          name: Generate collector -> rox version map
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/01-collector-to-rox-version-map.py" \
              "${SOURCE_ROOT}/RELEASED_VERSIONS" \
              /tmp/support-packages/metadata

      - run:
          name: Fetch collector metadata
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/02-fetch-collectors-metadata.sh" \
              /tmp/support-packages/metadata

      - run:
          name: Group by module version
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/03-group-by-module-version.sh" \
              /tmp/support-packages/metadata

      - run:
          name: Create support package files
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/04-create-support-packages.sh" \
              "${LICENSE_FILE}" /tmp/support-packages/metadata /tmp/support-packages/output

      - run:
          name: Create index file
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/05-create-index.py" \
              /tmp/support-packages/metadata /tmp/support-packages/output

      - run:
          name: Upload to GCloud
          command: |
            gsutil -m rsync -r /tmp/support-packages/output "$GCLOUD_TARGET"

      - run:
          name: Wait for 120 seconds
          command: |
            for i in {1..120}; do
              sleep 1
              echo -n .
            done
            echo

      - run:
          name: Delete old files
          command: |
            # Sanity check. If for some reason GCLOUD_TARGET is malformed, we risk deleting the
            # entire `sr-roxc` bucket (!!!). Hence have a hardcoded check for the path looking
            # valid.
            [[ "$GCLOUD_TARGET" =~ ^gs://[^/]+/.*collector.*/.*support-packages.*$ ]]
            # On non-master, additionally test that we have a .test indicator in the URL
            [[ "$CIRCLE_BRANCH" == "master" || "$GCLOUD_TARGET" = *.test* ]]
            gsutil -m rsync -n -r -d /tmp/support-packages/output "$GCLOUD_TARGET"

      - slack/status:
          fail_only: true
          mentions: SGX5Y89KJ
          only_for_branches: master
          webhook: '${SLACK_WEBHOOK_KERNEL_PROBE_BUILD_FAILURE}'

  reload-released-images:
    <<: *defaultMachine
    environment:
    - INSTALL_DIRECTORY: /tmp
    - RELOAD_MD_DIRECTORY: /tmp/reload/collectors
    - DOCKER_BUILDKIT: 1
    - QUAY_REPO: << pipeline.parameters.quay-repo >>
    - DOCKER_REPO: "docker.io/stackrox"
    working_directory: ~/workspace

    steps:
    - initcommand

    - run:
        name: Check if reload job should run and copy kernel objects
        command: |
          shopt -s nullglob
          mod_build_dir="${WORKSPACE_ROOT}/ko-build/build-output"
          if [[ ( "$CIRCLE_BRANCH" != "master" && ! -f "${WORKSPACE_ROOT}/pr-metadata/labels/reload-released-images" ) \
             || ( "$CIRCLE_BRANCH" == "master" && -z "$( find "${mod_build_dir}" -type f -name '*.gz' )" ) ]]; then
            echo "Not reloading released images"
            circleci step halt
            exit 0
          fi

          for mod_dir in "${WORKSPACE_ROOT}/ko-build/module-versions"/*/; do
            mod_ver="$(basename "$mod_dir")"
            echo "Checking for module version ${mod_ver}"
            [[ -d "${mod_build_dir}/${mod_ver}" ]] || continue
            [[ ! -z "$( find "${mod_build_dir}/${mod_ver}" -type f -name '*.gz' )" ]] || continue
            echo "Copying into container build directory for module version ${mod_ver}"
            container_build_dir="${WORKSPACE_ROOT}/images/${mod_ver}/container"
            mkdir -p "${container_build_dir}/kernel-modules"
            cp "${mod_build_dir}/${mod_ver}"/*.gz "${container_build_dir}/kernel-modules"
          done

    - docker-login-push
    - quay-login-push
    - stackrox-io-login
    - gcloud-init

    - run:
        name: Determine collector versions that need reload
        command: |
          mkdir -p "${RELOAD_MD_DIRECTORY}"
          for collector_ver_file in "${WORKSPACE_ROOT}/ko-build/released-collectors"/*; do
            collector_ver="$(basename "${collector_ver_file}")"
            mod_ver="$(< "${collector_ver_file}")"
            echo "Missing object check for module version: ${mod_ver} and collector version: ${collector_ver}"

            released_latest_image="${DOCKER_REPO}/collector:${collector_ver}-latest"
            docker pull -q "${released_latest_image}" | cat

            "${SOURCE_ROOT}/reload/missing-kernel-objects.sh" \
              "${collector_ver}" "${COLLECTOR_MODULES_BUCKET}" "${RELOAD_MD_DIRECTORY}"

            missing_objs_file="${RELOAD_MD_DIRECTORY}/${collector_ver}/missing-probes"
            if [[ ! -s "${missing_objs_file}" ]] ; then
              echo "Image ${released_latest_image} contains up to date kernel objects"
              continue
            fi

            echo "Found $(wc -l <"${missing_objs_file}") missing or updated kernel objects."
          done

    - store_artifacts:
        path: /tmp/reload/collectors

    - run:
        name: Sync module versions
        command: |
          for collector_dir in "/tmp/reload/collectors"/*; do
            cat "${collector_dir}/module-version"
          done | sort | uniq > /tmp/reload/module-versions

          while IFS='' read -r mod_ver || [[ -n "$mod_ver" ]]; do
            container_build_dir="${WORKSPACE_ROOT}/images/${mod_ver}/container"

            kernel_modules_dir="${container_build_dir}/kernel-modules"
            mkdir -p "${kernel_modules_dir}"
            echo "${mod_ver}" > "${kernel_modules_dir}/MODULE_VERSION.txt"

            # Sync kernel objects from GCS
            gsutil -m rsync -r -x ".*\.unavail$" \
              "${COLLECTOR_MODULES_BUCKET}/${mod_ver}/" "${kernel_modules_dir}" | cat

            # Copy Dockerfile and build scripts into build directory
            cp "${SOURCE_ROOT}/kernel-modules/container/"* "${container_build_dir}"
          done < /tmp/reload/module-versions

    - run:
        name: Reload collector images
        command: |
          for collector_dir in "${RELOAD_MD_DIRECTORY}"/*; do
            collector_ver="$(basename "${collector_dir}")"
            mod_ver="$(< "${collector_dir}/module-version")"


            container_build_dir="${WORKSPACE_ROOT}/images/${mod_ver}/container"
            layer_count="$("${container_build_dir}/partition-probes.py" -1 "$MAX_LAYER_MB" "${container_build_dir}/kernel-modules" "-")"

            echo "Reloading ${layer_count} image layers for collector ${collector_ver} (${mod_ver})"

            dockerhub_repo="${DOCKER_REPO}/collector:${collector_ver}"
            dockerhub_base_image="${dockerhub_repo}-base"
            dockerhub_pr_image="${dockerhub_repo}-reload-latest"
            dockerhub_image="${dockerhub_repo}-latest"

            quay_base_repo="${QUAY_REPO}/collector:${collector_ver}"
            quay_base_image="${quay_base_repo}-base"
            quay_pr_image="${quay_base_repo}-reload-latest"
            quay_image="${quay_base_repo}-latest"

            stackrox_io_image="collector.stackrox.io/collector:${collector_ver}-latest"

            image_list=(
              "${dockerhub_image}"
              "${dockerhub_base_image}"
              "${dockerhub_pr_image}"
              "${quay_image}"
              "${quay_base_image}"
              "${quay_pr_image}"
              "${stackrox_io_image}"
            )
            build_args=(
              --build-arg module_version="${mod_ver}"
              --build-arg collector_version="${collector_ver}"
              --build-arg collector_repo="${DOCKER_REPO}/collector"
              --build-arg max_layer_depth="${layer_count}"
              --build-arg max_layer_size="${MAX_LAYER_MB}"
            )
            docker build -q \
              --target="probe-layer-${layer_count}" \
              -t "${stackrox_io_image}" \
              -t "${dockerhub_image}" \
              -t "${dockerhub_pr_image}" \
              -t "${quay_pr_image}" \
              -t "${quay_image}" \
              "${build_args[@]}" \
              "${container_build_dir}"

            if [[ "$CIRCLE_BRANCH" != "master" && -z "$CIRCLE_TAG" ]]; then
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${dockerhub_pr_image}" | cat
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${quay_pr_image}" | cat
              image_list+=("${dockerhub_pr_image}-amd64" "${quay_pr_image}-amd64")
            else
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${dockerhub_image}" | cat
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${quay_image}" | cat
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${stackrox_io_image}" | cat
              image_list+=("${dockerhub_image}-amd64" "${quay_image}-amd64" "${stackrox_io_image}-amd64")
            fi
            # clean-up to reduce disk usage
            docker image rm -f "${image_list[@]}"
            docker image prune --force
            docker images
          done

    - slack/status:
        fail_only: true
        mentions: SGX5Y89KJ
        only_for_branches: master
        webhook: '${SLACK_WEBHOOK_KERNEL_PROBE_BUILD_FAILURE}'

workflows:
  version: 2
  build:
    jobs:
    - initjob:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - lint:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - initjob
    - builder:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - lint
    - collector:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - builder
    - builder-rhel:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - lint
    - collector-rhel:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - builder-rhel
    - prepare-kernels:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - lint
    - kernels:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - prepare-kernels
    - join-modules:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - kernels
    - upload-modules:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - join-modules
    - kernel-module-build-failures-check:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - kernels
    - images:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - collector
        - collector-rhel
        - kernels
        - join-modules
    - ubi-image:
        <<: *runOnAllTags
        context:
          - docker-io-push
          - quay-cgorman1-readwrite
          - redhat-developer-account-login
        requires:
        - initjob
    - integration-test-local:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - images
        - upload-modules
    - integration-test-local:
        <<: *runOnAllTagsWithDockerIOPushCtx
        name: integration-test-local-rhel
        vm-config: rhel
        use-rhel: true
        requires:
        - images
        - upload-modules
    - integration-test-local:
        <<: *runOnAllTagsWithDockerIOPushCtx
        name: integration-test-local-ubi
        vm-config: rhel
        use-ubi: true
        requires:
        - ubi-image
        - upload-modules
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-cos-stable
        collection_method: ebpf
        vm_type: cos
        image_family: cos-stable
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-cos-beta
        collection_method: ebpf
        vm_type: cos
        image_family: cos-beta
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-cos-dev
        collection_method: ebpf
        vm_type: cos
        image_family: cos-dev
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-cos-81-lts
        collection_method: ebpf
        vm_type: cos
        image_family: cos-81-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-cos-85-lts
        collection_method: ebpf
        vm_type: cos
        image_family: cos-85-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-cos-89-lts
        collection_method: ebpf
        vm_type: cos
        image_family: cos-89-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-rhel-7
        collection_method: ebpf
        vm_type: rhel
        image_family: rhel-7
    # TODO(rc) Enabled but bootstrap.sh forces fallback to kernel-module (ROX-3377)
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-rhel-7
        collection_method: module
        vm_type: rhel
        image_family: rhel-7
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-rhel-8
        collection_method: ebpf
        vm_type: rhel
        image_family: rhel-8
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-rhel-8
        collection_method: module
        vm_type: rhel
        image_family: rhel-8
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-ubuntu-1804-lts
        collection_method: ebpf
        vm_type: ubuntu-os
        image_family: ubuntu-1804-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-ubuntu-1604-lts-esm
        collection_method: module
        vm_type: ubuntu-os
        image_family: ubuntu-1604-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-ubuntu-1604-lts-esm
        collection_method: ebpf
        vm_type: ubuntu-os
        image_family: ubuntu-1604-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-ubuntu-1804-lts
        collection_method: module
        vm_type: ubuntu-os
        image_family: ubuntu-1804-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-ubuntu-2004-lts
        collection_method: ebpf
        vm_type: ubuntu-os
        image_family: ubuntu-2004-lts
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-ubuntu-2004-lts
        collection_method: module
        vm_type: ubuntu-os
        image_family: ubuntu-2004-lts
    # TODO(ROX-6790) - support glibc 2.33 for 5.11+ kernels
    #- integration-test:
    #    <<: *runOnAllTagsWithIntegrationTestRequires
    #    name: test-ebpf-ubuntu-2104
    #    collection_method: ebpf
    #    vm_type: ubuntu-os
    #    image_family: ubuntu-2104
    #- integration-test:
    #    <<: *runOnAllTagsWithIntegrationTestRequires
    #    name: test-module-ubuntu-2104
    #    collection_method: module
    #    vm_type: ubuntu-os
    #    image_family: ubuntu-2104
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-sles-15
        collection_method: ebpf
        vm_type: suse
        image_family: sles-15
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-sles-15
        collection_method: module
        vm_type: suse
        image_family: sles-15
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-sles-12
        collection_method: module
        vm_type: suse
        image_family: sles-12
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-sles-15-sp2-sap
        collection_method: ebpf
        vm_type: suse-sap
        image_family: sles-15-sp2-sap
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-sles-15-sp2-sap
        collection_method: module
        vm_type: suse-sap
        image_family: sles-15-sp2-sap
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-module-flatcar-stable
        collection_method: module
        vm_type: flatcar
        image_family: flatcar-stable
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-flatcar-stable
        collection_method: ebpf
        vm_type: flatcar
        image_family: flatcar-stable
    - integration-test-data:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - test-ebpf-cos-stable
        - test-ebpf-cos-beta
        - test-ebpf-cos-dev
        - test-ebpf-cos-81-lts
        - test-ebpf-cos-85-lts
        - test-ebpf-cos-89-lts
        - test-module-rhel-7
        - test-ebpf-rhel-7
        - test-module-rhel-8
        - test-ebpf-rhel-8
        - test-module-ubuntu-1604-lts-esm
        - test-ebpf-ubuntu-1604-lts-esm
        - test-module-ubuntu-1804-lts
        - test-ebpf-ubuntu-1804-lts
        - test-module-ubuntu-2004-lts
        - test-ebpf-ubuntu-2004-lts
        # TODO(ROX-6790) - support glibc 2.33 for 5.11+ kernels
        #- test-module-ubuntu-2104
        #- test-ebpf-ubuntu-2104
        - test-ebpf-sles-15
        - test-module-sles-15
        - test-module-sles-12
        - test-ebpf-sles-15-sp2-sap
        - test-module-sles-15-sp2-sap
        - test-ebpf-flatcar-stable
        - test-module-flatcar-stable
    - reload-released-images:
        <<: *runOnAllTags
        context:
          - docker-io-and-stackrox-io-push
          - quay-cgorman1-readwrite
        requires:
          - images
    - update-support-packages:
        <<: *runOnAllTags
        context:
          - docker-io-and-stackrox-io-push
          - quay-cgorman1-readonly
        requires:
          - upload-modules
