version: 2.1
parameters:
  quay-repo:
    type: string
    default: "quay.io/rhacs-eng"
  dockerized-parallel:
    type: integer
    default: 32
  dockerized-cache-tag:
    type: string
    default: cache-v2
  kernel-bundles-staging:
    type: string
    default: ""
  default-machine-image:
    type: string
    # https://circleci.com/docs/2.0/configuration-reference/#available-machine-images
    default: ubuntu-2004:202111-02

defaultImage: &defaultImage
  docker:
  - image: "<< pipeline.parameters.quay-repo >>/apollo-ci:collector-0.3.35"
    auth:
      username: $QUAY_RHACS_ENG_RO_USERNAME
      password: $QUAY_RHACS_ENG_RO_PASSWORD
  working_directory: ~/workspace
  environment:
    ROX_CI_IMAGE: true

defaultMachine: &defaultMachine
  machine:
    image: << pipeline.parameters.default-machine-image >>

runOnAllTags: &runOnAllTags
  filters:
    tags:
      only: /.*/

runOnAllTagsWithDockerIOPullCtx: &runOnAllTagsWithDockerIOPullCtx
  <<: *runOnAllTags
  context:
    - docker-io-pull
    - quay-rhacs-eng-readonly

runOnAllTagsWithDockerIOPushCtx: &runOnAllTagsWithDockerIOPushCtx
  <<: *runOnAllTags
  context:
    - docker-io-push
    - quay-rhacs-eng-readwrite
    - quay-rhacs-eng-readonly

runOnAllTagsWithIntegrationTestRequires: &runOnAllTagsWithIntegrationTestRequires
  <<: *runOnAllTags
  context:
    - docker-io-pull
    - quay-rhacs-eng-readonly
    - ubuntu-esm-subscription-token # Provides environment variable UBUNTU_ESM_SUBSCRIPTION_TOKEN.
    - redhat-developer-account-login
  requires:
  - images
  - ubi-image
  - integration-test-local
  - dockerized-build-collector

orbs:
  slack: circleci/slack@3.4.2
  ci-artifacts: stackrox/ci-artifacts-orb@0.1.1

commands:
  initcommand:
    steps:
    - attach_workspace:
        at: ~/workspace
    - run:
        name: Set up environment
        command: |
          cat >>"$BASH_ENV" \<<-EOF
            export WORKSPACE_ROOT="${HOME}/workspace"
          EOF
          [[ -f ~/workspace/shared-env ]] && cat ~/workspace/shared-env >>"$BASH_ENV"

  read-pr-metadata:
    steps:
    - run:
        name: Read PR metadata
        command: |
          ~/workspace/go/src/github.com/stackrox/collector/.circleci/read-labels.sh pr-metadata/labels

  gcloud-init:
    parameters:
      service-account-env:
        type: string
        default: GOOGLE_CREDENTIALS_CIRCLECI_COLLECTOR
      bucket-permission-check:
        type: string
        default: gs://collector-build-cache
    steps:
    - run:
        name: Install and configure gcloud
        working_directory: ~/.config/gcloud
        command: |
          "${CI_ROOT}/gcloud-init/install-and-configure-gcloud.sh"

    - run:
        name: Setup GCP env
        command: |
          "${CI_ROOT}/gcloud-init/setup-gcp-env.sh" "${<< parameters.service-account-env >>}" << parameters.bucket-permission-check >>

  docker-login-pull:
    steps:
    - run:
        name: Login to Docker Hub with pull credentials
        command: |
            docker login -u "$DOCKER_IO_PULL_USERNAME" -p "$DOCKER_IO_PULL_PASSWORD"

  docker-login-push:
    steps:
    - run:
        name: Login to Docker Hub with push credentials
        command: |
            docker login -u "$DOCKER_IO_PUSH_USERNAME" -p "$DOCKER_IO_PUSH_PASSWORD"

  quay-login:
    steps:
    - run:
        name: Login to Quay with pull credentials
        command: |
            docker login -u "$QUAY_RHACS_ENG_RO_USERNAME" -p "$QUAY_RHACS_ENG_RO_PASSWORD" quay.io

  quay-login-push:
    steps:
    - run:
        name: Login to Quay with push credentials
        command: |
            docker login -u "$QUAY_RHACS_ENG_RW_USERNAME" -p "$QUAY_RHACS_ENG_RW_PASSWORD" quay.io

  dockerized-pull-cache-image:
    steps:
    - run:
        name: Pull cache image
        command: |
          # If we are running with dockerized-no-cache, we create an empty image as base
          if [[ "${COLLECTOR_DRIVERS_CACHE}" == "no-cache" ]]; then
            docker run --name empty-cache registry.access.redhat.com/ubi8/ubi:8.5 mkdir -p /kernel-modules/
            docker commit empty-cache "<< pipeline.parameters.quay-repo >>/collector-drivers:$COLLECTOR_DRIVERS_CACHE"
            docker rm empty-cache
            exit 0
          fi

          # If we can't pull the cache image, we are either working with no cache or creating the cache itself.
          # In any case, we can create the empty image to account for this
          if ! docker pull "<< pipeline.parameters.quay-repo >>/collector-drivers:$COLLECTOR_DRIVERS_CACHE"; then
            docker run --name empty-cache registry.access.redhat.com/ubi8/ubi:8.5 mkdir -p /kernel-modules/
            docker commit empty-cache "<< pipeline.parameters.quay-repo >>/collector-drivers:$COLLECTOR_DRIVERS_CACHE"
            docker rm empty-cache
          fi

  dockerized-check-drivers-built:
    steps:
    - run:
        name: Check if job should run
        command: |
          if [[ ! -s ~/workspace/build-tasks ]]; then
            echo "Nothing was built, skipping this job"

            circleci step halt
            exit 0
          fi

  stackrox-io-login:
    steps:
    - run:
        name: Docker login to collector.stackrox.io
        command: |
          docker login \
            -u "$STACKROX_IO_PUSH_USERNAME" \
            -p "$STACKROX_IO_PUSH_PASSWORD" \
            collector.stackrox.io

jobs:
  initjob:
    <<: *defaultImage

    steps:
    - checkout:
        path: ~/workspace/go/src/github.com/stackrox/collector

    - add_ssh_keys:
        fingerprints:
        - "32:e2:6d:de:c3:bb:b8:a4:62:89:a1:df:7a:30:37:f2"

    - run:
        name: "Pull git submodule"
        command: |
          git -C ~/workspace/go/src/github.com/stackrox/collector submodule update --init

    - run:
        name: Set up shared environment
        command: |
          cat >~/workspace/shared-env \<<-"EOF"
            export GOPATH="${WORKSPACE_ROOT}/go"
            export SOURCE_ROOT="${GOPATH}/src/github.com/stackrox/collector"
            export CI_ROOT="${SOURCE_ROOT}/.circleci"
            export COLLECTOR_SOURCE_ROOT="${SOURCE_ROOT}/collector"
            export PATH="${PATH}:${GOPATH}/bin:${WORKSPACE_ROOT}/bin"
            export MAX_LAYER_MB=300
          EOF

    - read-pr-metadata

    - run:
        name: Set COLLECTOR_VERSION
        command: |
          COLLECTOR_VERSION="$(make -s -C ~/workspace/go/src/github.com/stackrox/collector tag)"

          COLLECTOR_TAG="${COLLECTOR_VERSION}"
          GCLOUD_SSH_FINGERPRINT="$(echo ${GCLOUD_SSH_KEY_PUB} | awk '{print $2}' | base64 -d | md5sum | awk '{print $1}')"
          GCP_SSH_KEY_FILE="${HOME}/.ssh/id_rsa_${GCLOUD_SSH_FINGERPRINT}"

          cat >> ~/workspace/shared-env \<<-EOF
            export COLLECTOR_VERSION="${COLLECTOR_VERSION}"
            export COLLECTOR_TAG="${COLLECTOR_TAG}"
            export GCP_SSH_KEY_FILE="${GCP_SSH_KEY_FILE}"
          EOF

          if [[ -z "$CIRCLE_TAG" && "$CIRCLE_BRANCH" != "master" ]]; then
          cat >> ~/workspace/shared-env \<<- EOF
            export COLLECTOR_APPEND_CID=true
          EOF
          fi

          if [[ -z "$CIRCLE_TAG" && "$CIRCLE_BRANCH" != "master" && ! -f pr-metadata/labels/build-builder-image && ! -f pr-metadata/labels/valgrind-unit-tests && ! -f pr-metadata/labels/valgrind-integration-tests ]]; then
          cat >> ~/workspace/shared-env \<<-EOF
            export COLLECTOR_BUILDER_TAG="cache"
          EOF
          else
          cat >> ~/workspace/shared-env \<<-EOF
            export COLLECTOR_BUILDER_TAG="circle-build-${CIRCLE_WORKFLOW_ID}"
            export BUILD_BUILDER_IMAGE=true
          EOF
          fi

          COLLECTOR_DRIVERS_CACHE="<< pipeline.parameters.dockerized-cache-tag >>"
          COLLECTOR_DRIVERS_TAG="circle-build-${CIRCLE_WORKFLOW_ID}"
          if [[ -f pr-metadata/labels/dockerized-no-cache ]]; then
            COLLECTOR_DRIVERS_CACHE="no-cache"
          fi

          if [[ -n "$CIRCLE_TAG" || "$CIRCLE_BRANCH" == "master" ]]; then
            COLLECTOR_DRIVERS_CACHE="<< pipeline.parameters.dockerized-cache-tag >>"
            COLLECTOR_DRIVERS_TAG="<< pipeline.parameters.dockerized-cache-tag >>"
          fi

          cat >> ~/workspace/shared-env \<<-EOF
            export COLLECTOR_DRIVERS_CACHE="${COLLECTOR_DRIVERS_CACHE}"
            export COLLECTOR_DRIVERS_TAG="${COLLECTOR_DRIVERS_TAG}"
          EOF

          cat ~/workspace/shared-env

    - run:
        name: Set label environment variables
        command: |
          if [[ -f pr-metadata/labels/build-legacy-probes ]]; then
            echo 'export BUILD_LEGACY_PROBES=true' >> ~/workspace/shared-env
          else
            echo 'export BUILD_LEGACY_PROBES=false' >> ~/workspace/shared-env
          fi

          if [[ -f pr-metadata/labels/build-full-images ]]; then
            echo 'export BUILD_FULL_IMAGES=true' >> ~/workspace/shared-env
          else
            echo 'export BUILD_FULL_IMAGES=false' >> ~/workspace/shared-env
          fi

          if [[ -f pr-metadata/labels/debug ]]; then
            echo 'export CMAKE_BUILD_TYPE=Debug' >> ~/workspace/shared-env
          else
            echo 'export CMAKE_BUILD_TYPE=Release' >> ~/workspace/shared-env
          fi

          # Loops over all possible types of Valgrind tests, checks the labels, and sets environment variables accordingly
          # Default is not to use Valgrind, but build with Valgrind if any Valgrind label is present
          BUILD_USE_VALGRIND="false"
          for test_type in unit-tests integration-tests
          do
            CHECK_VALGRIND="false"
            for valgrind_test_type in helgrind valgrind
            do
              up_valgrind_test_type=${valgrind_test_type^^}
              up_test_type="$(echo ${test_type^^} | sed 's|-|_|')"

              if [[ -f pr-metadata/labels/${valgrind_test_type}-${test_type} ]]; then
                echo "export ${up_valgrind_test_type}_${up_test_type}=true" >> ~/workspace/shared-env
                CHECK_VALGRIND="true"
                BUILD_USE_VALGRIND="true"
              else
                echo "export ${up_valgrind_test_type}_${up_test_type}=false" >> ~/workspace/shared-env
              fi
            done
            echo "export CHECK_${up_valgrind_test_type}_${up_test_type}=$CHECK_VALGRIND" >> ~/workspace/shared-env
          done
          echo "export BUILD_USE_VALGRIND=$BUILD_USE_VALGRIND" >> ~/workspace/shared-env

          if [[ -f pr-metadata/labels/address-sanitizer ]]; then
            echo 'export SANITIZER_TESTS=true' >> ~/workspace/shared-env
          else
            echo 'export SANITIZER_TESTS=false' >> ~/workspace/shared-env
          fi

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - go/src/github.com/stackrox/collector
        - pr-metadata
        - shared-env

  lint:
    <<: *defaultImage
    steps:
    - initcommand
    - run:
        name: Lint via clang-format
        command: |
           make -C "${COLLECTOR_SOURCE_ROOT}" check

    - run:
        name: Lint via shfmt
        command: |
          go install mvdan.cc/sh/v3/cmd/shfmt@v3.4.1
          make -C "${SOURCE_ROOT}" shfmt-check

  test-scripts:
    <<: *defaultImage

    steps:
    - initcommand

    - run:
        name: Test get-builder-flavor
        command: |
          "${CI_ROOT}/test-scripts/get-builder-flavor/run-tests.sh" "${SOURCE_ROOT}"

    - run:
        name: shellcheck-all
        command: |
          wget -qO- "https://github.com/koalaman/shellcheck/releases/download/stable/shellcheck-stable.linux.x86_64.tar.xz" | tar -xJv
          sudo cp "shellcheck-stable/shellcheck" /usr/bin/
          make -C "${SOURCE_ROOT}" shellcheck-all

  builder:
    <<: *defaultMachine
    resource_class: large

    steps:
    - initcommand
    - docker-login-push

    - run:
        name: Restore collector-builder image
        command: |
          docker pull "stackrox/collector-builder:${COLLECTOR_BUILDER_TAG}" || docker pull stackrox/collector-builder:cache || true

    - run:
        name: Build collector-builder image
        command: |
          make -C "${SOURCE_ROOT}" builder

    - run:
        name: Save collector-builder image
        command: |
          "${CI_ROOT}/builder/save-collector-builder-image.sh" "${CIRCLE_BRANCH}"

  prepare-kernels:
    <<: *defaultImage

    steps:
    - initcommand

    - run:
        name: Prepare source
        command: |
          "${CI_ROOT}/prepare-kernels/prepare-source.sh"

    - run:
        name: Prepare legacy sources
        command: |
          "${CI_ROOT}/prepare-kernels/prepare-legacy-sources.sh" "${CIRCLE_TAG}" "${CIRCLE_BRANCH}"

    - run:
        name: Prepare Kernel module build cache lookup
        command: |
          "${CI_ROOT}/prepare-kernels/prepare-kernel-module-build-cache-lookup.sh"

    - restore_cache:
        name: Restore Kernel module build cache
        keys:
          - kernel-module-cache-v18-{{ checksum "/tmp/cache/kernel-modules-version.txt" }}-{{ .Branch }}-{{ .Revision }}
          - kernel-module-cache-v18-{{ checksum "/tmp/cache/kernel-modules-version.txt" }}-master-

    - run:
        name: Unpack module sources
        command: |
          "${CI_ROOT}/prepare-kernels/unpack-module-sources.sh"

    - run:
        name: Copy cached modules to build output
        command: |
          "${CI_ROOT}/prepare-kernels/copy-cached-modules-to-build-output.sh"

    - gcloud-init

    - run:
        name: Upload module sources
        command: |
          gsutil -m rsync -r ~/kobuild-tmp/versions-src/ "gs://stackrox-kernel-modules-source/collector/"

    - run:
        name: Download missing modules for CURRENT version from gcloud bucket
        command: |
          "${CI_ROOT}/prepare-kernels/download-missing-modules-for-current-version-from-gcloud-bucket.sh"

    - run:
        name: Patch module sources
        command: |
          "${CI_ROOT}/prepare-kernels/patch-module-sources.sh"

    - run:
        name: Compile list of cached modules for CURRENT module version
        command: |
          "${CI_ROOT}/prepare-kernels/compile-list-of-cached-modules-for-current-module-version.sh"

    - run:
        name: Compile list of existing modules for LEGACY module versions
        command: |
          "${CI_ROOT}/prepare-kernels/compile-list-of-existing-modules-for-legacy-module-versions.sh"

    - run:
        name: Generate list of all (source, kernel version) build combinations
        command: |
          "${CI_ROOT}/prepare-kernels/generate-list-of-all-build-combinations.sh"

    - run:
        name: Print list of all (source, kernel version) build combinations
        command: |
          "${CI_ROOT}/prepare-kernels/print-list-of-all-build-combinations.sh"

    - ci-artifacts/store:
        path: ~/kobuild-tmp
    - persist_to_workspace:
        root: ~/workspace
        paths:
          - ko-build
          - bin
          - shared-env

  kernels:
    <<: *defaultMachine
    parallelism: 32
    environment:
    - BUILD_CONTAINER_TAG: stackrox/collector-builder:kobuilder-cache
    - BUILD_CONTAINER_CACHE_IMAGES: stackrox/collector-builder:kobuilder-cache
    - KERNEL_BUNDLES_STAGING_BUCKET: "<< pipeline.parameters.kernel-bundles-staging >>"

    steps:
    - initcommand

    - run:
        name: Determine tasks for current shard
        command: |
          "${CI_ROOT}/kernels/determine-tasks-for-current-shard.sh" "${CIRCLE_NODE_TOTAL}" "${CIRCLE_NODE_INDEX}"

    - gcloud-init
    - run:
        name: Download required packages
        command: |
          "${CI_ROOT}/kernels/download-required-packages.sh" "${CIRCLE_TAG}" "${CIRCLE_BRANCH}" ~/kobuild-tmp

    - run:
        name: Determine versions requiring a custom builder flavor
        command: |
          "${CI_ROOT}/kernels/determine-versions-requiring-a-custom-builder-flavor.sh" ~/kobuild-tmp

    - run:
        name: Separate local build tasks by flavor
        command: |
          "${CI_ROOT}/kernels/separate-local-build-tasks-by-flavor.sh"

    - docker-login-push

    - run:
        name: Restore builder cache image(s)
        command: |
          make -C "${SOURCE_ROOT}/kernel-modules" pull-build-containers

    - run:
        name: Build builder image
        command: |
          "${CI_ROOT}/kernels/build-builder-image.sh"

    - run:
        name: Upload builder cache image
        command: |
          # [[ "$CIRCLE_BRANCH" == "master" ]] || exit 0
          (( CIRCLE_NODE_INDEX == 0 )) || exit 0
          make -C "${SOURCE_ROOT}/kernel-modules" push-build-containers
        background: true

    - run:
        name: Build modules
        command: |
          "${CI_ROOT}/kernels/build-modules.sh" "${CIRCLE_NODE_INDEX}"

    - run:
        name: Print built modules
        command: |
          "${CI_ROOT}/kernels/print-built-modules.sh" "${CIRCLE_NODE_INDEX}"

    - persist_to_workspace:
        root: ~/workspace
        paths:
          - ko-build/build-output/shard-*
          - ko-build/build-output/FAILURES-*

  collector:
    <<: *defaultMachine
    resource_class: large
    environment:
      UNITTEST_OUTPUT_FILE: unittest_results.txt

    steps:
    - initcommand
    - read-pr-metadata
    - docker-login-push

    - run:
        name: Restore collector-builder image
        command: |
          "${CI_ROOT}/collector/10-restore-collector-builder-image.sh"

    - run:
        name: Build collector
        command: |
          "${CI_ROOT}/collector/20-build-collector.sh"

    - run:
        name: Run collector unit tests
        command: |
          "${CI_ROOT}/collector/30-run-collector-unit-tests.sh"

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - go/src/github.com/stackrox/collector/collector/container/bin
        - go/src/github.com/stackrox/collector/collector/container/libs
        - go/src/github.com/stackrox/collector/collector/container/THIRD_PARTY_NOTICES

  images:
    <<: *defaultMachine
    environment:
    - INSTALL_DIRECTORY: /tmp
    - QUAY_REPO: << pipeline.parameters.quay-repo >>
    - DOCKER_REPO: "docker.io/stackrox"

    steps:
    - initcommand
    - docker-login-push
    - quay-login-push
    - gcloud-init

    - run:
        name: Copying Kernel modules build output
        command: |
          "${CI_ROOT}/images/10-copying-kernel-modules-build-output.sh"

    - run:
        name: Copying Kernel modules from cache
        command: |
          "${CI_ROOT}/images/20-copying-kernel-modules-from-cache.sh"

    - run:
        name: Preparing Kernel modules build cache
        command: |
          "${CI_ROOT}/images/30-preparing-kernel-modules-build-cache.sh"

    - save_cache:
        name: Saving Kernel module build cache
        key: kernel-module-cache-v18-{{ checksum "/tmp/cache/kernel-modules-version.txt" }}-{{ .Branch }}-{{ .Revision }}
        paths:
          - /tmp/cache/

    - run:
        name: Adding Kernel module version and license files
        command: |
          "${CI_ROOT}/images/40-adding-kernel-module-version-and-license-files.sh"

    - run:
        name: Load any missing modules from GCloud
        command: |
          "${CI_ROOT}/images/50-load-any-missing-modules-from-gcloud.sh"

    - run:
        name: Sanity check
        command: |
          "${CI_ROOT}/images/60-sanity-check.sh"

    - run:
        name: Build collector slim and base images
        command: |
          "${CI_ROOT}/images/70-build-collector-slim-and-base-images.sh"

    - run:
        name: Build collector -latest images
        command: |
          "${CI_ROOT}/images/80-build-collector-latest-images.sh" "${CIRCLE_BRANCH}" "${CIRCLE_TAG}"

    - run:
        name: Sanity check images
        command: |
          "${CI_ROOT}/images/90-sanity-check-images.sh"

    - run:
        name: Push images
        command: |
          "${CI_ROOT}/images/100-push-images.sh"

  ubi-image:
    machine:
      image: << pipeline.parameters.default-machine-image >>
      docker_layer_caching: true
    resource_class: large
    environment:
    - QUAY_REPO: << pipeline.parameters.quay-repo >>
    - DOCKER_REPO: "docker.io/stackrox"

    steps:
    - initcommand
    - docker-login-push
    - quay-login-push
    - run:
        name: Lint Dockerfile
        command: |
          "${CI_ROOT}/ubi-images/10-lint-dockerfile.sh"

    - run:
        name: Build collector UBI images
        command: |
          "${CI_ROOT}/ubi-images/20-build-collector-ubi-images.sh"

    - run:
        name: Push collector UBI images
        command: |
          "${CI_ROOT}/ubi-images/30-push-collector-ubi-images.sh"

  kernel-module-build-failures-check:
    <<: *defaultImage

    steps:
      - initcommand

      - run:
          name: Save failures files
          command: |
            "${CI_ROOT}/kernel-module-build-failures-check/10-save-failures-files.sh"

      - run:
          name: Test for build failures
          command: |
            "${CI_ROOT}/kernel-module-build-failures-check/20-test-for-build-failures.sh"

      - ci-artifacts/store:
          path: /tmp/failures

      - slack/status:
          fail_only: true
          mentions: SGX5Y89KJ
          only_for_branches: master
          webhook: '${SLACK_WEBHOOK_KERNEL_PROBE_BUILD_FAILURE}'

  join-modules:
    <<: *defaultImage

    steps:
      - initcommand

      - run:
          name: Consolidate modules built by sharded jobs
          command: |
            "${CI_ROOT}/join-modules/10-consolidate-modules-built-by-sharded-jobs.sh"

      - persist_to_workspace:
          root: ~/workspace
          paths:
            - ko-build/built-probes/

  upload-modules:
    <<: *defaultImage

    steps:
      - initcommand
      - gcloud-init

      - run:
          name: Remove failures file and shard output dirs
          command: |
            "${CI_ROOT}/upload-modules/10-remove-failures-file-and-shard-output-dirs.sh"

      - run:
          name: Uploading Kernel modules
          command: |
            "${CI_ROOT}/upload-modules/20-uploading-kernel-modules.sh" "${CIRCLE_TAG}" "${CIRCLE_BRANCH}" "${CIRCLE_BUILD_NUM}"

      - run:
          name: Sanity check
          command: |
            "${CI_ROOT}/upload-modules/30-sanity-check.sh" "${CIRCLE_TAG}" "${CIRCLE_BRANCH}"


  dockerized-task-file:
    <<: *defaultMachine

    steps:
    - initcommand
    - docker-login-pull
    - quay-login
    - dockerized-pull-cache-image

    - run:
        name: Create task files
        command: |
          GIT_REF="${CIRCLE_BRANCH}"
          if [[ -n "${CIRCLE_TAG}" ]]; then
            GIT_REF="${CIRCLE_TAG}"
          fi

          "${SOURCE_ROOT}/.circleci/dockerized-drivers/create-task-file.sh" \
            "<< pipeline.parameters.quay-repo >>" \
            "<< pipeline.parameters.dockerized-parallel >>" \
            "${CIRCLE_NODE_INDEX}" \
            "${GIT_REF}"

    - persist_to_workspace:
        root: ~/workspace
        paths:
          - task-shard-*
          - build-tasks

  dockerized-build-drivers:
    <<: *defaultMachine
    parallelism: << pipeline.parameters.dockerized-parallel >>
    environment:
    - KERNEL_BUNDLES_STAGING_BUCKET: "<< pipeline.parameters.kernel-bundles-staging >>"

    steps:
    - initcommand
    - dockerized-check-drivers-built

    - run:
        name: Check shard needs to run
        command: |
          if [[ ! -s "${WORKSPACE_ROOT}/task-shard-$(printf '%02d' "$CIRCLE_NODE_INDEX")" ]]; then
            echo "Nothing to be done for this shard."

            circleci step halt
            exit 0
          fi

    - gcloud-init
    - docker-login-pull
    - quay-login-push
    - dockerized-pull-cache-image

    - run:
        name: Download required bundles
        command: |
          echo "Nodes total: $CIRCLE_NODE_TOTAL"
          echo "Node index:  $CIRCLE_NODE_INDEX"

          ## Get the bundles for the running machine
          "${SOURCE_ROOT}/.circleci/kernels/download-required-packages.sh" \
            "${CIRCLE_TAG}" \
            "${CIRCLE_BRANCH}" \
            "${WORKSPACE_ROOT}/go/src/github.com/stackrox" \
            "${WORKSPACE_ROOT}/task-shard-$(printf '%02d' "$CIRCLE_NODE_INDEX")"

    - run:
        name: Build drivers
        command: |
          GIT_REF="${CIRCLE_BRANCH}"
          if [[ -n "${CIRCLE_TAG}" ]]; then
            GIT_REF="${CIRCLE_TAG}"
          fi

          "${SOURCE_ROOT}/.circleci/dockerized-drivers/build-drivers.sh" \
            "<< pipeline.parameters.quay-repo >>" \
            "${GIT_REF}" \
            "${CIRCLE_NODE_INDEX}"

  dockerized-unify-images:
    <<: *defaultMachine

    steps:
    - initcommand
    - docker-login-pull
    - quay-login-push
    - dockerized-pull-cache-image

    - run:
        name: Unify images
        command: |
          "${SOURCE_ROOT}/.circleci/dockerized-drivers/unify-images.sh" \
            "<< pipeline.parameters.quay-repo >>" \
            "<< pipeline.parameters.dockerized-parallel >>"

  dockerized-check-failures:
    <<: *defaultMachine

    steps:
    - initcommand
    - dockerized-check-drivers-built
    - quay-login

    - run:
        name: Test for build failures
        command: |
          "${SOURCE_ROOT}/.circleci/dockerized-drivers/check-failures.sh" \
            "<< pipeline.parameters.quay-repo >>"

    - store_artifacts:
        path: /tmp/dockerized-failures

  dockerized-build-collector:
    <<: *defaultMachine

    steps:
    - initcommand
    - quay-login
    - docker-login-push

    - run:
        name: Build full collector image
        command: |
          "${SOURCE_ROOT}/.circleci/dockerized-drivers/build-full-collector.sh" \
            "docker.io/stackrox"

  integration-test-local:
    parameters:
      vm-config:
        type: string
        default: default
      use-ubi:
        type: boolean
        default: false

    <<: *defaultMachine
    working_directory: ~/workspace

    steps:
    - initcommand
    - docker-login-push
    - read-pr-metadata
    - gcloud-init

    - run:
        name: "Running integration tests"
        no_output_timeout: 45m
        command: |
          export REMOTE_HOST_TYPE=local
          export COLLECTION_METHOD="kernel_module"
          export VM_CONFIG="circle_local_<< parameters.vm-config >>"
          export COLLECTOR_REPO="stackrox/collector<<# parameters.use-ubi>>-test-cpaas<</ parameters.use-ubi>>"
          export COLLECTOR_IMAGE="${COLLECTOR_REPO}:${COLLECTOR_TAG}"
          export USE_VALGRIND=$VALGRIND_INTEGRATION_TESTS
          export USE_HELGRIND=$HELGRIND_INTEGRATION_TESTS
          make -C "${SOURCE_ROOT}" integration-tests-repeat-network integration-tests-missing-proc-scrape integration-tests-image-label-json integration-tests integration-tests-report
          [[ -z "$CIRCLE_BRANCH" ]] || gsutil cp ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml "gs://stackrox-ci-results/circleci/collector/${CIRCLE_BRANCH}/$(date +%Y-%m-%d)-${CIRCLE_BUILD_NUM}/"

    - run:
        name: "Check Valgrind errors"
        command: |
          if [[ "$CHECK_VALGRIND_INTEGRATION_TESTS" != "true" ]]; then
            echo "Not using Valgrind. Not checking for Valgrind errors"
            exit 0
          fi
          echo "Using Valgrind"
          log_dir=~/workspace/go/src/github.com/stackrox/collector/integration-tests/container-logs
          for file in "$log_dir"/*-collector.log
          do
            "${CI_ROOT}/check-file-for-valgrind-errors.sh" "$file" "$VALGRIND_INTEGRATION_TESTS" "$HELGRIND_INTEGRATION_TESTS"
          done

    - store_test_results:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
    - ci-artifacts/store:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
        destination: "integration-test-report.xml"
    - ci-artifacts/store:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/container-logs
        destination: "container-logs"
    - ci-artifacts/store:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/perf.json
        destination: "kernel_module-circle_local_<< parameters.vm-config >>-perf.json"

  integration-test:
    parameters:
      collection_method:
        type: enum
        enum: [module, ebpf]
      vm_type:
        type: enum
        enum: [cos, rhel, suse, suse-sap, ubuntu-os-pro, ubuntu-os, flatcar, fedora-coreos, garden-linux]
      image_family:
        type: enum
        enum: [
          cos-77-lts,
          cos-85-lts,
          cos-89-lts,
          cos-beta,
          cos-dev,
          cos-stable,
          fedora-coreos-stable,
          flatcar-stable,
          garden-linux,
          rhel-7,
          rhel-8,
          sles-12,
          sles-15,
          sles-15-sp2-sap,
          ubuntu-1804-lts,
          ubuntu-2004-lts,
          ubuntu-2110,
          ubuntu-pro-1804-lts
        ]
      image_name:
        type: string
        default: "unset"
      image_version:
        type: string
        default: ""
      offline:
        type: boolean
        default: false
      dockerized:
        type: boolean
        default: false
    <<: *defaultMachine
    working_directory: ~/workspace

    steps:
    - initcommand
    - docker-login-pull

    - run:
        name: Check whether to run job
        command: |
          if [[ -f ~/workspace/pr-metadata/labels/skip-integration-tests ]]; then
            echo "Skipping job with skip-integration-tests label."
            circleci step halt
            exit 0
          fi
    - add_ssh_keys
    - read-pr-metadata
    - gcloud-init

    - run:
        name: "Setup env vars"
        command: |
          COLLECTOR_REPO="stackrox/collector"
          if "${CI_ROOT}/pr_has_label.sh" ci-run-against-ubi; then
            COLLECTOR_REPO="stackrox/collector-test-cpaas"
          fi
          TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          cat >>"$BASH_ENV" \<<-EOF
            export COLLECTION_METHOD="<< parameters.collection_method >>"
            export COLLECTOR_OFFLINE_MODE="<< parameters.offline >>"
            export GCLOUD_INSTANCE="collector-ci-${TEST_NAME}-${CIRCLE_BUILD_NUM}"
            export GCLOUD_OPTIONS="--ssh-key-file=${GCP_SSH_KEY_FILE}"
            export IMAGE_FAMILY=<< parameters.image_family >>
            export IMAGE_NAME=<< parameters.image_name >>
            export REMOTE_HOST_TYPE=gcloud
            export TEST_NAME="${TEST_NAME}"
            export VM_CONFIG="<< parameters.vm_type >>.<< parameters.image_family >>"
            export VM_TYPE=<< parameters.vm_type >>
            export COLLECTOR_REPO="${COLLECTOR_REPO}"
            export USE_VALGRIND=$VALGRIND_INTEGRATION_TESTS
            export USE_HELGRIND=$HELGRIND_INTEGRATION_TESTS
          EOF

    - run:
        name: "Extract gcp ssh public key from environment variable"
        command: |
          echo "${GCLOUD_SSH_KEY_PUB}" > "${GCP_SSH_KEY_FILE}.pub"
          chmod 0600 "${GCP_SSH_KEY_FILE}.pub"

    - run:
        name: "Create VM"
        command: |
          source $SOURCE_ROOT/.circleci/create-vm.sh
          main "$GCLOUD_INSTANCE" "$VM_TYPE" "$IMAGE_FAMILY" "$IMAGE_NAME" "$GCP_SSH_KEY_FILE" "$DOCKER_IO_PULL_USERNAME" "$DOCKER_IO_PULL_PASSWORD"

    - run:
        name: "Running integration tests"
        no_output_timeout: 45m
        command: |
          <<# parameters.dockerized >>export COLLECTOR_IMAGE="${COLLECTOR_REPO}:${COLLECTOR_TAG}-dockerized"<</ parameters.dockerized >>
          echo "Running tests with image '${COLLECTOR_IMAGE}'"
          make -C "${SOURCE_ROOT}" integration-tests-repeat-network integration-tests-baseline integration-tests integration-tests-report
          cp "${SOURCE_ROOT}/integration-tests/perf.json" "${WORKSPACE_ROOT}/${TEST_NAME}-perf.json"
          [[ -z "$CIRCLE_BRANCH" ]] || gsutil cp "${SOURCE_ROOT}/integration-tests/integration-test-report.xml" "gs://stackrox-ci-results/circleci/collector/${CIRCLE_BRANCH}/$(date +%Y-%m-%d)-${CIRCLE_BUILD_NUM}/"

    - run:
        name: "Check Valgrind errors"
        command: |
          if [[ "$CHECK_VALGRIND_INTEGRATION_TESTS" != "true" ]]; then
            echo "Not using Valgrind. Not checking for Valgrind errors"
            exit 0
          fi
          echo "Using Valgrind"
          log_dir=~/workspace/go/src/github.com/stackrox/collector/integration-tests/container-logs
          for file in "$log_dir"/*-collector.log
          do
            "${CI_ROOT}/check-file-for-valgrind-errors.sh" "$file" "$VALGRIND_INTEGRATION_TESTS" "$HELGRIND_INTEGRATION_TESTS"
          done

    - run:
        name: "Get serial port output"
        command: |
          export TEST_NAME="<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>"
          export GCLOUD_INSTANCE="collector-ci-${TEST_NAME}-${CIRCLE_BUILD_NUM}"
          mkdir -p ~/workspace/serial-output
          gcloud compute instances get-serial-port-output "$GCLOUD_INSTANCE" > ~/workspace/serial-output/"$GCLOUD_INSTANCE"-serial-output.logs
        when: always

    - store_test_results:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
    - ci-artifacts/store:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/integration-test-report.xml
        destination: "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-integration-test-report.xml"
    - ci-artifacts/store:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/container-logs
        destination: "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-container-logs"
    - ci-artifacts/store:
        path: ~/workspace/go/src/github.com/stackrox/collector/integration-tests/perf.json
        destination: "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-perf.json"
    - ci-artifacts/store:
        path: ~/workspace/serial-output

    - persist_to_workspace:
        root: ~/workspace
        paths:
        - "<< parameters.collection_method >>-<< parameters.vm_type >>-<< parameters.image_family >>-perf.json"

    - run:
        name: "Destroy VM"
        command: |
          gcloud compute instances delete $GCLOUD_INSTANCE
        when: always

  integration-test-data:
    <<: *defaultImage

    steps:
    - initcommand
    - run:
        name: Check whether to run job
        command: |
          if [[ -f ~/workspace/pr-metadata/labels/skip-integration-tests ]]; then
            echo "Skipping job with skip-integration-tests label."
            circleci step halt
            exit 0
          fi

    - run:
        name: "Gather Data"
        command: |
          echo "ls 1"
          for i in "${WORKSPACE_ROOT}"/*perf.json; do
            echo "Performance data file: $i"
            cat $i >> ~/workspace/all-perf.json
          done
          ## TODO put into script
          cat all-perf.json | jq '. | select(.Metrics.hackbench_avg_time != null) | {kernel: .VmConfig, collection_method: .CollectionMethod, (.TestName): .Metrics.hackbench_avg_time } ' | jq -rs  ' group_by(.kernel) | .[] | group_by(.collection_method) | .[] | add | [.kernel, .collection_method, .baseline_benchmark, .collector_benchmark ] | @csv' > ~/workspace/benchmark.csv
          cat ~/workspace/benchmark.csv | sort | awk -v FS="," 'BEGIN{print "|Kernel|Method|Without Collector Time (secs)|With Collector Time (secs)|";print "|---|---|---|---|"}{printf "|%s|%s|%s|%s|%s",$1,$2,$3,$4,ORS}' > ~/workspace/benchmark.md

    - run:
        name: Comment on PR
        command: |
          wget --quiet https://github.com/joshdk/hub-comment/releases/download/0.1.0-rc6/hub-comment_linux_amd64
          sudo install hub-comment_linux_amd64 /usr/bin/hub-comment

          export COLLECTOR_TAG="${COLLECTOR_TAG}"
          export COLLECTOR_BUILDER_TAG="${COLLECTOR_BUILDER_TAG}"
          export PERF_TABLE=$(cat ~/workspace/benchmark.md)
          hub-comment -template-file "${CI_ROOT}/performance-comment-template.tpl"

    - ci-artifacts/store:
        path: ~/workspace/all-perf.json
    - ci-artifacts/store:
        path: ~/workspace/benchmark.md
    - ci-artifacts/store:
        path: ~/workspace/benchmark.csv

  update-support-packages:
    <<: *defaultImage
    environment:
      - DOWNLOAD_BASE_URL: "https://install.stackrox.io"
      - RELATIVE_PATH: "collector/support-packages"
      - GCLOUD_BUCKET: "gs://sr-roxc"
      - PUBLIC_RELATIVE_PATH: "offline/v1/support-packages"
      - PUBLIC_GCLOUD_BUCKET: "gs://collector-support-public"

    steps:
      - initcommand
      - read-pr-metadata
      - run:
          name: Check whether to run job
          command: |
            if [[ "$CIRCLE_BRANCH" != "master" && ! -f ~/workspace/pr-metadata/labels/test-support-packages ]]; then
              echo "On a PR without the test-support-packages label. Not building support packages."
              circleci step halt
            fi

      - setup_remote_docker:
          version: 20.10.11
      - stackrox-io-login
      - gcloud-init

      - run:
          name: Initialize environment
          command: |
            relative_path="$RELATIVE_PATH"
            if [[ "$CIRCLE_BRANCH" != "master" ]]; then
              relative_path="${relative_path}/.test-${CIRCLE_BUILD_NUM}"
            fi
            cci-export BASE_URL "${DOWNLOAD_BASE_URL}/${relative_path}"
            cci-export SUPPORT_PKG_SRC_ROOT "${SOURCE_ROOT}/kernel-modules/support-packages"
            cci-export LICENSE_FILE "${SOURCE_ROOT}/collector/LICENSE-kernel-modules.txt"
            cci-export GCLOUD_TARGET "${GCLOUD_BUCKET}/${relative_path}"
            cci-export PUBLIC_GCLOUD_TARGET "${PUBLIC_GCLOUD_BUCKET}/${PUBLIC_RELATIVE_PATH}"

      - run:
          name: Install Jinja2
          command: |
            pip install Jinja2

      - run:
          name: Generate collector -> rox version map
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/01-collector-to-rox-version-map.py" \
              "${SOURCE_ROOT}/RELEASED_VERSIONS" \
              /tmp/support-packages/metadata

      - run:
          name: Fetch collector metadata
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/02-fetch-collectors-metadata.sh" \
              /tmp/support-packages/metadata

      - run:
          name: Group by module version
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/03-group-by-module-version.sh" \
              /tmp/support-packages/metadata

      - run:
          name: Create support package files
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/04-create-support-packages.sh" \
              "${LICENSE_FILE}" /tmp/support-packages/metadata /tmp/support-packages/output

      - run:
          name: Create index file
          command: |
            "${SUPPORT_PKG_SRC_ROOT}/05-create-index.py" \
              /tmp/support-packages/metadata /tmp/support-packages/output

      - run:
          name: Upload to GCloud
          command: |
            gsutil -m rsync -r /tmp/support-packages/output "$GCLOUD_TARGET"

      - run:
          name: Wait for 120 seconds
          command: |
            for i in {1..120}; do
              sleep 1
              echo -n .
            done
            echo

      - run:
          name: Delete old files
          command: |
            # Sanity check. If for some reason GCLOUD_TARGET is malformed, we risk deleting the
            # entire `sr-roxc` bucket (!!!). Hence have a hardcoded check for the path looking
            # valid.
            [[ "$GCLOUD_TARGET" =~ ^gs://[^/]+/.*collector.*/.*support-packages.*$ ]]
            # On non-master, additionally test that we have a .test indicator in the URL
            [[ "$CIRCLE_BRANCH" == "master" || "$GCLOUD_TARGET" = *.test* ]]
            gsutil -m rsync -n -r -d /tmp/support-packages/output "$GCLOUD_TARGET"

      - gcloud-init:
          service-account-env: GCP_SERVICE_ACCOUNT_CREDS
          bucket-permission-check: $PUBLIC_GCLOUD_BUCKET

      - run:
          name: Upload to Public GCloud Bucket if on master
          command: |
            if [[ "$CIRCLE_BRANCH" != "master" ]]; then
              exit 0
            fi
            # Sync support packages
            gsutil -m rsync -r /tmp/support-packages/output "$PUBLIC_GCLOUD_TARGET"

            # Sleep for 120s
            for i in {1..120}; do
              sleep 1
              echo -n .
            done
            echo

            # Delete old files
            gsutil -m rsync -n -r -d /tmp/support-packages/output "$PUBLIC_GCLOUD_TARGET"

      - slack/status:
          fail_only: true
          mentions: SGX5Y89KJ
          only_for_branches: master
          webhook: '${SLACK_WEBHOOK_KERNEL_PROBE_BUILD_FAILURE}'

  reload-released-images:
    <<: *defaultMachine
    environment:
    - INSTALL_DIRECTORY: /tmp
    - RELOAD_MD_DIRECTORY: /tmp/reload/collectors
    - DOCKER_BUILDKIT: 1
    - QUAY_REPO: << pipeline.parameters.quay-repo >>
    - DOCKER_REPO: "docker.io/stackrox"
    working_directory: ~/workspace

    steps:
    - initcommand

    - run:
        name: Check if reload job should run and copy kernel objects
        command: |
          shopt -s nullglob
          mod_build_dir="${WORKSPACE_ROOT}/ko-build/build-output"
          if [[ ( "$CIRCLE_BRANCH" != "master" && ! -f "${WORKSPACE_ROOT}/pr-metadata/labels/reload-released-images" ) \
             || ( "$CIRCLE_BRANCH" == "master" && -z "$( find "${mod_build_dir}" -type f -name '*.gz' )" ) ]]; then
            echo "Not reloading released images"
            circleci step halt
            exit 0
          fi

          for mod_dir in "${WORKSPACE_ROOT}/ko-build/module-versions"/*/; do
            mod_ver="$(basename "$mod_dir")"
            echo "Checking for module version ${mod_ver}"
            [[ -d "${mod_build_dir}/${mod_ver}" ]] || continue
            [[ ! -z "$( find "${mod_build_dir}/${mod_ver}" -type f -name '*.gz' )" ]] || continue
            echo "Copying into container build directory for module version ${mod_ver}"
            container_build_dir="${WORKSPACE_ROOT}/images/${mod_ver}/container"
            mkdir -p "${container_build_dir}/kernel-modules"
            cp "${mod_build_dir}/${mod_ver}"/*.gz "${container_build_dir}/kernel-modules"
          done

    - docker-login-push
    - quay-login-push
    - stackrox-io-login
    - gcloud-init

    - run:
        name: Determine collector versions that need reload
        command: |
          mkdir -p "${RELOAD_MD_DIRECTORY}"
          for collector_ver_file in "${WORKSPACE_ROOT}/ko-build/released-collectors"/*; do
            collector_ver="$(basename "${collector_ver_file}")"
            mod_ver="$(< "${collector_ver_file}")"
            echo "Missing object check for module version: ${mod_ver} and collector version: ${collector_ver}"

            released_latest_image="${DOCKER_REPO}/collector:${collector_ver}-latest"
            docker pull -q "${released_latest_image}" | cat

            "${SOURCE_ROOT}/reload/missing-kernel-objects.sh" \
              "${collector_ver}" "${COLLECTOR_MODULES_BUCKET}" "${RELOAD_MD_DIRECTORY}"

            missing_objs_file="${RELOAD_MD_DIRECTORY}/${collector_ver}/missing-probes"
            if [[ ! -s "${missing_objs_file}" ]] ; then
              echo "Image ${released_latest_image} contains up to date kernel objects"
              continue
            fi

            echo "Found $(wc -l <"${missing_objs_file}") missing or updated kernel objects."
          done

    - ci-artifacts/store:
        path: /tmp/reload/collectors

    - run:
        name: Sync module versions
        command: |
          for collector_dir in "/tmp/reload/collectors"/*; do
            cat "${collector_dir}/module-version"
          done | sort | uniq > /tmp/reload/module-versions

          while IFS='' read -r mod_ver || [[ -n "$mod_ver" ]]; do
            container_build_dir="${WORKSPACE_ROOT}/images/${mod_ver}/container"

            kernel_modules_dir="${container_build_dir}/kernel-modules"
            mkdir -p "${kernel_modules_dir}"
            echo "${mod_ver}" > "${kernel_modules_dir}/MODULE_VERSION.txt"

            # Sync kernel objects from GCS
            gsutil -m rsync -r -x ".*\.unavail$" \
              "${COLLECTOR_MODULES_BUCKET}/${mod_ver}/" "${kernel_modules_dir}" | cat

            # Copy Dockerfile and build scripts into build directory
            cp "${SOURCE_ROOT}/kernel-modules/container/"* "${container_build_dir}"
          done < /tmp/reload/module-versions

    - run:
        name: Reload collector images
        command: |
          for collector_dir in "${RELOAD_MD_DIRECTORY}"/*; do
            collector_ver="$(basename "${collector_dir}")"
            mod_ver="$(< "${collector_dir}/module-version")"


            container_build_dir="${WORKSPACE_ROOT}/images/${mod_ver}/container"
            layer_count="$("${container_build_dir}/partition-probes.py" -1 "$MAX_LAYER_MB" "${container_build_dir}/kernel-modules" "-")"

            echo "Reloading ${layer_count} image layers for collector ${collector_ver} (${mod_ver})"

            dockerhub_repo="${DOCKER_REPO}/collector:${collector_ver}"
            dockerhub_base_image="${dockerhub_repo}-base"
            dockerhub_pr_image="${dockerhub_repo}-reload-latest"
            dockerhub_image="${dockerhub_repo}-latest"

            quay_base_repo="${QUAY_REPO}/collector:${collector_ver}"
            quay_base_image="${quay_base_repo}-base"
            quay_pr_image="${quay_base_repo}-reload-latest"
            quay_image="${quay_base_repo}-latest"

            stackrox_io_image="collector.stackrox.io/collector:${collector_ver}-latest"

            image_list=(
              "${dockerhub_image}"
              "${dockerhub_base_image}"
              "${dockerhub_pr_image}"
              "${quay_image}"
              "${quay_base_image}"
              "${quay_pr_image}"
              "${stackrox_io_image}"
            )
            build_args=(
              --build-arg module_version="${mod_ver}"
              --build-arg collector_version="${collector_ver}"
              --build-arg collector_repo="${DOCKER_REPO}/collector"
              --build-arg max_layer_depth="${layer_count}"
              --build-arg max_layer_size="${MAX_LAYER_MB}"
              --build-arg USE_VALGRIND="${BUILD_USE_VALGRIND}"
              --build-arg ADDRESS_SANITIZER="${SANITIZER_TESTS}"
            )
            docker build -q \
              --target="probe-layer-${layer_count}" \
              -t "${stackrox_io_image}" \
              -t "${dockerhub_image}" \
              -t "${dockerhub_pr_image}" \
              -t "${quay_pr_image}" \
              -t "${quay_image}" \
              "${build_args[@]}" \
              "${container_build_dir}"

            if [[ "$CIRCLE_BRANCH" != "master" && -z "$CIRCLE_TAG" ]]; then
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${dockerhub_pr_image}" | cat
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${quay_pr_image}" | cat
              image_list+=("${dockerhub_pr_image}-amd64" "${quay_pr_image}-amd64")
            else
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${dockerhub_image}" | cat
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${quay_image}" | cat
              ~/workspace/go/src/github.com/stackrox/collector/scripts/push-as-manifest-list.sh "${stackrox_io_image}" | cat
              image_list+=("${dockerhub_image}-amd64" "${quay_image}-amd64" "${stackrox_io_image}-amd64")
            fi
            # clean-up to reduce disk usage
            docker image rm -f "${image_list[@]}"
            docker image prune --force
            docker images
          done

    - slack/status:
        fail_only: true
        mentions: SGX5Y89KJ
        only_for_branches: master
        webhook: '${SLACK_WEBHOOK_KERNEL_PROBE_BUILD_FAILURE}'

workflows:
  version: 2
  build:
    jobs:
    - initjob:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - lint:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - initjob
    - test-scripts:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - initjob
    - builder:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - lint
    - collector:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - builder
    - dockerized-task-file:
        <<: *runOnAllTags
        context:
          - docker-io-pull
          - quay-rhacs-eng-readonly
          - redhat-developer-account-login
        requires:
        - lint
    - dockerized-build-drivers:
        <<: *runOnAllTags
        context:
          - docker-io-pull
          - quay-rhacs-eng-readwrite
          - redhat-developer-account-login
        requires:
        - dockerized-task-file
    - dockerized-unify-images:
        <<: *runOnAllTags
        context:
          - docker-io-pull
          - quay-rhacs-eng-readwrite
        requires:
          - dockerized-build-drivers
    - dockerized-check-failures:
        <<: *runOnAllTags
        context:
          - quay-rhacs-eng-readonly
        requires:
          - dockerized-unify-images
    - dockerized-build-collector:
        <<: *runOnAllTags
        context:
          - docker-io-push
          - quay-rhacs-eng-readonly
        requires:
          - dockerized-unify-images
          - images
    - prepare-kernels:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - lint
    - kernels:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - prepare-kernels
    - join-modules:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - kernels
    - upload-modules:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - join-modules
    - kernel-module-build-failures-check:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - kernels
    - images:
        <<: *runOnAllTagsWithDockerIOPushCtx
        requires:
        - collector
        - kernels
        - join-modules
    - ubi-image:
        <<: *runOnAllTags
        context:
          - docker-io-push
          - quay-rhacs-eng-readwrite
          - redhat-developer-account-login
        requires:
        - initjob
    - integration-test-local:
        <<: *runOnAllTagsWithDockerIOPushCtx
        name: integration-test-local
        vm-config: rhel
        requires:
        - images
        - upload-modules
    - integration-test-local:
        <<: *runOnAllTagsWithDockerIOPushCtx
        name: integration-test-local-ubi
        vm-config: rhel
        use-ubi: true
        requires:
        - ubi-image
        - upload-modules
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-ebpf-<< matrix.image_family >><<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        vm_type: cos
        collection_method: ebpf
        matrix:
          parameters:
            image_family: [cos-stable, cos-beta, cos-dev, cos-85-lts, cos-89-lts]
            dockerized: [false, true]
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-<< matrix.image_family >><<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        vm_type: rhel
        matrix:
          parameters:
            image_family: [rhel-7, rhel-8]
            collection_method: [module, ebpf]
            dockerized: [false, true]
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-<< matrix.image_family >><<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        vm_type: ubuntu-os
        matrix:
          parameters:
            image_family: [ubuntu-1804-lts, ubuntu-2004-lts, ubuntu-2110]
            collection_method: [module, ebpf]
            dockerized: [false, true]
          exclude:
            # Failing due to GLIC 2.33 not available on ubi 8
            - image_family: ubuntu-2110
              collection_method: module
              dockerized: true
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-<< matrix.image_family >><<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        vm_type: ubuntu-os-pro
        matrix:
          parameters:
            image_family: [ubuntu-pro-1804-lts]
            collection_method: [module, ebpf]
            dockerized: [false, true]
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-<< matrix.image_family >><<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        vm_type: suse
        matrix:
          parameters:
            image_family: [sles-12, sles-15]
            collection_method: [module, ebpf]
            dockerized: [false, true]
          exclude:
            - image_family: sles-12
              collection_method: ebpf
              dockerized: false
            - image_family: sles-12
              collection_method: ebpf
              dockerized: true
    # Removed while solving ROX-9180
    # - integration-test:
    #     <<: *runOnAllTagsWithIntegrationTestRequires
    #     name: test-<< matrix.collection_method >>-sles-15-sp2-sap<<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
    #     vm_type: suse-sap
    #     image_family: sles-15-sp2-sap
    #     matrix:
    #       parameters:
    #         collection_method: [module, ebpf]
    #         dockerized: [false, true]
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-flatcar-stable<<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        vm_type: flatcar
        image_family: flatcar-stable
        matrix:
          parameters:
            collection_method: [module, ebpf]
            dockerized: [false, true]
          exclude:
            # Failing due to GLIC 2.33 not available on ubi 8
            - collection_method: module
              dockerized: true
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-fedora-coreos-stable<<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        image_family: fedora-coreos-stable
        vm_type: fedora-coreos
        matrix:
          parameters:
            collection_method: [module, ebpf]
            dockerized: [false, true]
          exclude:
            # Failing due to GLIC 2.33 not available on ubi 8
            - collection_method: module
              dockerized: true
    - integration-test:
        <<: *runOnAllTagsWithIntegrationTestRequires
        name: test-<< matrix.collection_method >>-garden-linux<<# matrix.dockerized >>-dockerized<</ matrix.dockerized >>
        image_family: garden-linux
        image_name: gardenlinux-gcp-cloud-gardener--prod-<< matrix.image_version >>
        vm_type: garden-linux
        matrix:
          parameters:
            collection_method: [module, ebpf]
            dockerized: [false, true]
            image_version: [576-7-7d3c7d]
          exclude:
            # Failing due to dockerized module not being built (requires gcc-10).
            - collection_method: module
              dockerized: true
              image_version: 576-7-7d3c7d
    - integration-test-data:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
        - test-ebpf-cos-stable
        - test-ebpf-cos-beta
        - test-ebpf-cos-dev
        - test-ebpf-cos-85-lts
        - test-ebpf-cos-89-lts
        - test-module-rhel-7
        - test-ebpf-rhel-7
        - test-module-rhel-8
        - test-ebpf-rhel-8
        - test-module-ubuntu-1804-lts
        - test-ebpf-ubuntu-1804-lts
        - test-module-ubuntu-2004-lts
        - test-ebpf-ubuntu-2004-lts
        - test-module-ubuntu-2110
        - test-ebpf-ubuntu-2110
        - test-ebpf-sles-15
        - test-module-sles-15
        - test-module-sles-12
        # Removed while solving ROX-9180
        # - test-ebpf-sles-15-sp2-sap
        # - test-module-sles-15-sp2-sap
        - test-ebpf-flatcar-stable
        - test-module-flatcar-stable
        - test-ebpf-fedora-coreos-stable
        - test-module-fedora-coreos-stable
        - test-ebpf-garden-linux
        - test-module-garden-linux
        - test-module-ubuntu-pro-1804-lts
        - test-ebpf-ubuntu-pro-1804-lts
    - reload-released-images:
        <<: *runOnAllTags
        context:
          - docker-io-and-stackrox-io-push
          - quay-rhacs-eng-readwrite
        requires:
          - images
    - update-support-packages:
        <<: *runOnAllTags
        context:
          - docker-io-and-stackrox-io-push
          - quay-rhacs-eng-readonly
          - collector-support
        requires:
          - upload-modules
