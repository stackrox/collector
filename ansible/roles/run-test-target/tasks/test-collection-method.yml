---
#
# This will run the steps for integration testing, for a given collection method.
# and handles creating the report and writing necessary log files.
#
# Args:
#   collection_method: ebpf
#

- set_fact:
    logs_root: "{{ collector_root }}/integration-tests/container-logs/{{ vm_config }}/{{ collection_method }}"

- name: Cleanup old containers
  become: "{{ runtime_as_root }}"
  shell: "{{ runtime_command }} rm -f $({{ runtime_command }} ps -aq) >/dev/null 2>&1 || true"

- name: Get default collector tag
  community.general.make:
    target: tag
    chdir: "{{ collector_root }}"
  register: collector_tag_result
  delegate_to: localhost

- set_fact:
    collector_image: "{{ lookup('env', 'COLLECTOR_IMAGE', default='quay.io/rhacs-eng/collector:' +  collector_tag_result.stdout) }}"
    integration_tests_image: "{{ lookup('env', 'TEST_IMAGE', default='quay.io/rhacs-eng/qa-multi-arch:collector-tests-' + collector_tag_result.stdout }}"

- set_fact:
    run_args: -run {{ collector_test }} -timeout 60m -count=1
  when: collector_test != "ci-integration-tests"

- set_fact:
    run_args: -timeout 120m -short
  when: collector_test == "ci-integration-tests"

- block:
  - name: Run integration tests
    shell: |
      {% if runtime_as_root %}sudo{% endif %} \
        {{ runtime_command }} -it --rm \
          -v /tmp:{{ remote_logs_root }} \
          -v ~/.docker:/root/.docker \
          -e COLLECTION_METHOD='{{ collection_method }}' \
          -e VM_CONFIG='{{ vm_config }}' \
          -e IMAGE_FAMILY='{{ vm_image_family }}' \
          -e RUNTIME_COMMAND='{{ runtime_command }}' \
          -e RUNTIME_AS_ROOT='{{ runtime_as_root }}' \
          -e RUNTIME_SOCKET='{{ runtime_socket }}' \
          -e COLLECTOR_IMAGE='{{ collector_image }}' \
          -e COLLECTOR_QA_TAG='{{ lookup('env', 'COLLECTOR_QA_TAG', default=lookup('file', integration_tests_root + '/container/QA_TAG')) }}'
          {{ integration_tests_image }} \
          {{ run_args }} -v 2>&1
    register: test_result
    # ensure that this is printed
    tags: [print_action]

  rescue:
    - name: Set tests as failed
      set_fact:
        success: false

    - name: Output test log
      debug:
        msg: "{{ test_result.stdout }}"
      tags: [print_action]

  always:
    - name: Make logs directories
      file:
        state: directory
        path: "{{ logs_root }}"
      delegate_to: localhost

    - name: Get log files
      find:
        paths: "{{ remote_logs_root }}/{{ vm_config }}/{{ collection_method }}/"
      register: remote_log_files

    - name: Fetch log files
      fetch:
        src: "{{ remote_log_path }}"
        dest: "{{ logs_root }}/"
        flat: true
      loop: "{{ remote_log_files.files | map(attribute='path') | list }}"
      loop_control:
        loop_var: remote_log_path

    - name: Download perf JSON
      fetch:
        src: "{{ remote_tests_root }}/perf.json"
        dest: "{{ integration_tests_root }}/"
        flat: true
        fail_on_missing: false

    - name: Write integration test log
      copy:
        content: "{{ test_result.stdout }}"
        dest: "{{ logs_root }}/integration-test.log"
      delegate_to: localhost

    - name: Report
      community.general.make:
        chdir: "{{ integration_tests_root }}"
        target: report
      environment:
        LOG_FILE: "{{ logs_root }}/integration-test.log"
      delegate_to: localhost

  # If this host is just for a certain collection method, skip running
  # the test if we're not using that collection method.
  when: vm_collection_method == collection_method or vm_collection_method == 'any'
