syntax = "proto3";

package data;

option java_outer_classname = "FeatureVectorProtosV2";

message FeatureVectorV2 {
    double y = 1; // response variable, if any (type double to support both regression and classification)

    map<uint32, double> x = 2; // independent variables, sparse format

    map<uint32, double> importance = 3; // non-negative importance weights, sparse format

    string tag = 4; // A tag to mark the vector with

    map<uint32, Namespace> namespace = 5; // The namespaces tied to indices, sparse format

    enum Namespace {
        UNKNOWN_NAMESPACE = 0;
        FILE = 1;
        FLOW = 2;
        PROCESS = 3;
        DOCKER = 4; // Really container, but needed to differentiate with the Scope enum level
        FILTER = 9999;
    }

    enum Windowing {
        UNKNOWN_WINDOWING = 0;
        TIME_WINDOW_1S = 1;
        TIME_WINDOW_2S = 2;
        FILE_SUMMARY = 3;
        FLOW_SUMMARY = 4;
    }

    enum Scope {
        UNKNOWN_SCOPE = 0;
        CONTAINER = 1;
        SERVICE = 2;
        APPLICATION = 3;
        HOST = 4;
    }

    message RoxMetadata { // All metadata tied to the vector needed for generating context
        string scope_id = 1; // The identifier tied to the vector's scope
        Scope scope = 2; // The scope of the data contained in the vector
        Windowing windowing = 3; // The windowing mechanism used to generate the feature vector
        map<uint32, int64> index_to_signal_timestamp = 4;
        map<uint32, string> index_to_context_string = 5;
        map<uint32, bool> index_to_event_bool = 6; // Whether or not an index should be used to generate a stand-alone event
    }

    RoxMetadata metadata = 8;

    repeated string data_sources = 9; // The summary ids used to build the feature vector.

    int64 emit_timestamp_ns = 10;
}
